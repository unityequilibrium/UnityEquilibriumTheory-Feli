# UET Vector Database — Design Guide

**Date:** 2026-02-12
**Status:** ✅ **IMPLEMENTED** (Phase 6 Completed)
**Purpose:** Design Guide for UET Vector Database (Actual Implementation Record)

---

## 1. ข้อมูลที่ต้องจัดการ

โครงการ UET มี 27+ หัวข้อวิจัย ใน `research_uet/topics/` รวม 9,144+ ไฟล์:

```
research_uet/topics/
├── 0.0_Grand_Unification/     # ทฤษฎีรวมใหญ่
├── 0.1_Quantum_Mechanics/     # กลศาสตร์ควอนตัม
├── 0.2_General_Relativity/    # สัมพัทธภาพทั่วไป
├── 0.3_Consciousness/         # จิตสำนึก
├── ...27 topics...
├── 0.25_Robotics/
└── 0.26_Swarm_Intelligence/
```

แต่ละ topic มีข้อมูล 4 ประเภท:
| ประเภท | ตัวอย่าง | ต้อง index |
|:-------|:---------|:----------|
| **Code** | `Research_*.py` — สคริปต์ที่รันจริง | ✅ ต้อง — เป็นตัวหลัก |
| **Results** | `data_logs/`, plots, computed values | ✅ ต้อง — ผลลัพธ์จริง |
| **Documentation** | `README.md`, theory notes | ✅ ต้อง — อธิบายทฤษฎี |
| **References** | `.bib`, citations | ⚡ optional |

---

## 2. หลักการออกแบบ: ประยุกต์ UET Physics มาใช้

### 2.1 Vector Embedding ต้องมาจาก UET Equations

UET Master Equation คือ coupled field PDE:
```
∂C/∂t = κ∇²C − ∂V/∂C − β(C − I) + s
∂I/∂t = κ∇²I − ∂V/∂I − β(I − C)
```

แต่ละเอกสาร/ข้อมูลมี "UET signature" ที่ดึงได้จากสมการจริง:

| Feature | มาจากไหน | ความหมาย |
|:--------|:---------|:---------|
| **Ω (Omega)** | `Ω = ∫(C−I)² dx` จาก `uet_master_equation.py` | Gap ระหว่าง reality กับ information — ยิ่งต่ำยิ่ง equilibrium |
| **κ (Kappa)** | `uet_parameters.py` | Diffusion rate — ความเร็วที่ information กระจาย |
| **β (Beta)** | Coupling strength | ความเชื่อมโยงระหว่าง C กับ I |
| **Shannon Entropy H** | `H = −Σ pᵢ log₂ pᵢ` | Information density ของเนื้อหา |
| **Axiom Signature** | 12 axiom detection | เอกสารเกี่ยวข้องกับ axiom ไหนบ้าง (binary vector) |
| **Topic Coupling** | β matrix ระหว่าง topics | topic นี้เชื่อมกับ topic อื่นแค่ไหน |

### 2.2 Similarity Search ใช้ Ω-minimization

แทนที่จะใช้ cosine similarity ธรรมดา:
```python
# ❌ Generic approach
similarity = cosine(doc_a_embedding, doc_b_embedding)

# ✅ UET approach: minimize Ω between query and results
Ω_gap = compute_omega(query_field, result_field)
relevance = 1.0 / (1.0 + Ω_gap)  # ยิ่ง Ω ต่ำ ยิ่งเกี่ยวข้อง
```

### 2.3 Cross-topic Connections ใช้ Multi-field Coupling

27 topics = 27 fields ในระบบ multi-field UET:
```
∂Cᵢ/∂t = κᵢ∇²Cᵢ − ∂V/∂Cᵢ − Σⱼ βᵢⱼ(Cᵢ − Cⱼ) + sᵢ
```
- `βᵢⱼ` = coupling strength ระหว่าง topic i กับ j
- คำนวณจากการ share axioms, shared imports, shared parameters
- ใช้เป็น graph index สำหรับ cross-topic search

---

## 3. Architecture ที่ถูกต้อง

```
┌─────────────────────────────────────────────────┐
│                  Query Interface                 │
│        "find research related to Ω > 2.0"        │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│              Ω-Search Engine                     │
│  1. Parse query → UET parameters                 │
│  2. Compute Ω-distance to indexed items          │
│  3. Apply topic coupling weights                 │
│  4. Return ranked results                        │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│              Vector Store                        │
│  **Selected: Option A (SQLite + numpy)**         │
│  (Implemented in Phase 2)                        │
│                                                  │
│  Schema (Verified):                              │
│  ├── doc_id: "topic_0.0_chunk_12"                │
│  ├── topic_id: "0.0_Grand_Unification"           │
│  ├── text: "Actual chunk content..."             │
│  ├── uet_vec: [Ω, κ, β, H, axioms...] (BLOB)     │
│  └── metadata: JSON                              │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│              UET Tensorizer                      │
│  Input: any file from research_uet/             │
│  Process:                                        │
│  1. Extract imports → dependency graph           │
│  2. Run UET engine → compute Ω, κ, β            │
│  3. Detect axiom references → 12-bit signature   │
│  4. Compute Shannon entropy H                    │
│  5. Output: UET vector (fixed-size)              │
│                                                  │
│  Uses: research_uet.core.uet_master_equation    │
│  NOT ad-hoc math — delegates to real engine      │
└─────────────────────────────────────────────────┘
```

---

## 4. Rust Compatibility

### ที่ต้องรู้
- Rust ใช้อยู่แล้วใน `0.18_Mathnicry/rust_miner/` (tokio + wgpu + rayon + serde)
- โครงการจะย้ายไป Rust ทั้งหมดในอนาคต แต่ยังไม่ใช่ตอนนี้

### กฎออกแบบ
1. **Data structures = Rust-compatible:** ใช้ fixed-size arrays, structs ที่ map ไป `#[repr(C)]` ได้
2. **Serialization = serde-compatible:** JSON/MessagePack ที่ Rust serde อ่านได้
3. **No Python-only tricks:** ไม่ใช้ pickle, ไม่ใช้ dynamic typing ใน stored data
4. **Core algorithm แยกชัด:** ถ้าวันหลังจะเขียน Rust ใหม่ ต้องรู้ว่า algorithm อยู่ตรงไหน

```rust
// ตัวอย่าง: struct ที่ Rust จะใช้ในอนาคต
#[derive(Serialize, Deserialize)]
struct UetVector {
    omega: f64,
    kappa: f64,
    beta: f64,
    entropy: f64,
    axiom_signature: [bool; 12],
    topic_id: String,
    content_hash: [u8; 32],
}
```

Python version ต้องสร้าง data ในรูปแบบเดียวกัน:
```python
@dataclass
class UetVector:
    omega: float
    kappa: float
    beta: float
    entropy: float
    axiom_signature: list[bool]  # len=12
    topic_id: str
    content_hash: bytes  # 32 bytes
```

---

## 5. Implementation Log (Completed Phases)

### Phase 1: UET Tensorizer (`tensorizer.py`) ✅
- Implemented `UetTensorizer` class.
- Delegates to `uet_master_equation.py`.
- Verified 100% deterministic output for Ω, κ, β.

### Phase 2: Vector Store (`vector_store.py`) ✅
- Built on `sqlite3` + `numpy`.
- Zero external dependencies.
- Handles 19,430 document chunks efficiently.

### Phase 3: Ω-Search Engine (`omega_search.py`) ✅
- Implemented `search_uet` (Physics) and prepared `search_semantic`.
- Hybrid search capability via `alpha` parameter.

### Phase 4: Ingestion (`ingest.py`) ✅
- Processed 9,139 files in ~98 seconds.
- Chunking strategy: 1000 chars with overlap.

### Phase 5: Multi-Agent System (`agents/`) ✅
- `Orchestrator`: Intelligent routing using `qwen/qwen3-coder-next`.
- `ResearchAgent`: RAG-enabled using Ω-Search.
- `EquationExpert`: Solves math using `deepseek-r1`.

---

## 6. ข้อควรระวัง

1. **Disk เหลือ ~2.5 MB** — ต้อง free space ก่อน หรือใช้ SQLite (ไม่ต้องติดตั้ง)
2. **ทำทีละขั้น** — สร้าง 1 module → ทดสอบ → คุย → แล้วค่อยต่อ
3. **ใช้ engine จริง** — delegate ไป `uet_master_equation.py` ไม่ใช่เขียน math เอง
4. **ห้ามประดิษฐ์ format ขึ้นมาเอง** — vector dimensions ต้องมีเหตุผลทาง physics
5. **ข้อมูลเก่าใน `ทองข้อมูลดี/`** — ใช้อ้างอิงได้ แต่ห้ามใช้เป็น design spec
