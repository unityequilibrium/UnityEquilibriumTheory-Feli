# UET Vector Database — Design Guide

**Date:** 2026-02-11
**Purpose:** วิธีออกแบบ Vector Database สำหรับโครงการ UET ที่ถูกต้อง ให้ session หน้าทำตามได้เลย

---

## 1. ข้อมูลที่ต้องจัดการ

โครงการ UET มี 27+ หัวข้อวิจัย ใน `research_uet/topics/` รวม 9,144+ ไฟล์:

```
research_uet/topics/
├── 0.0_Grand_Unification/     # ทฤษฎีรวมใหญ่
├── 0.1_Quantum_Mechanics/     # กลศาสตร์ควอนตัม
├── 0.2_General_Relativity/    # สัมพัทธภาพทั่วไป
├── 0.3_Consciousness/         # จิตสำนึก
├── ...27 topics...
├── 0.25_Robotics/
└── 0.26_Swarm_Intelligence/
```

แต่ละ topic มีข้อมูล 4 ประเภท:
| ประเภท | ตัวอย่าง | ต้อง index |
|:-------|:---------|:----------|
| **Code** | `Research_*.py` — สคริปต์ที่รันจริง | ✅ ต้อง — เป็นตัวหลัก |
| **Results** | `data_logs/`, plots, computed values | ✅ ต้อง — ผลลัพธ์จริง |
| **Documentation** | `README.md`, theory notes | ✅ ต้อง — อธิบายทฤษฎี |
| **References** | `.bib`, citations | ⚡ optional |

---

## 2. หลักการออกแบบ: ประยุกต์ UET Physics มาใช้

### 2.1 Vector Embedding ต้องมาจาก UET Equations

UET Master Equation คือ coupled field PDE:
```
∂C/∂t = κ∇²C − ∂V/∂C − β(C − I) + s
∂I/∂t = κ∇²I − ∂V/∂I − β(I − C)
```

แต่ละเอกสาร/ข้อมูลมี "UET signature" ที่ดึงได้จากสมการจริง:

| Feature | มาจากไหน | ความหมาย |
|:--------|:---------|:---------|
| **Ω (Omega)** | `Ω = ∫(C−I)² dx` จาก `uet_master_equation.py` | Gap ระหว่าง reality กับ information — ยิ่งต่ำยิ่ง equilibrium |
| **κ (Kappa)** | `uet_parameters.py` | Diffusion rate — ความเร็วที่ information กระจาย |
| **β (Beta)** | Coupling strength | ความเชื่อมโยงระหว่าง C กับ I |
| **Shannon Entropy H** | `H = −Σ pᵢ log₂ pᵢ` | Information density ของเนื้อหา |
| **Axiom Signature** | 12 axiom detection | เอกสารเกี่ยวข้องกับ axiom ไหนบ้าง (binary vector) |
| **Topic Coupling** | β matrix ระหว่าง topics | topic นี้เชื่อมกับ topic อื่นแค่ไหน |

### 2.2 Similarity Search ใช้ Ω-minimization

แทนที่จะใช้ cosine similarity ธรรมดา:
```python
# ❌ Generic approach
similarity = cosine(doc_a_embedding, doc_b_embedding)

# ✅ UET approach: minimize Ω between query and results
Ω_gap = compute_omega(query_field, result_field)
relevance = 1.0 / (1.0 + Ω_gap)  # ยิ่ง Ω ต่ำ ยิ่งเกี่ยวข้อง
```

### 2.3 Cross-topic Connections ใช้ Multi-field Coupling

27 topics = 27 fields ในระบบ multi-field UET:
```
∂Cᵢ/∂t = κᵢ∇²Cᵢ − ∂V/∂Cᵢ − Σⱼ βᵢⱼ(Cᵢ − Cⱼ) + sᵢ
```
- `βᵢⱼ` = coupling strength ระหว่าง topic i กับ j
- คำนวณจากการ share axioms, shared imports, shared parameters
- ใช้เป็น graph index สำหรับ cross-topic search

---

## 3. Architecture ที่ถูกต้อง

```
┌─────────────────────────────────────────────────┐
│                  Query Interface                 │
│        "find research related to Ω > 2.0"        │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│              Ω-Search Engine                     │
│  1. Parse query → UET parameters                 │
│  2. Compute Ω-distance to indexed items          │
│  3. Apply topic coupling weights                 │
│  4. Return ranked results                        │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│              Vector Store                        │
│  Option A: SQLite + numpy (simple, no install)   │
│  Option B: PostgreSQL + pgvector (if available)  │
│  Option C: Qdrant (if scale needed)              │
│                                                  │
│  Each record:                                    │
│  ├── topic_id: "0.1_Quantum_Mechanics"           │
│  ├── file_path: "Research_Quantum.py"            │
│  ├── uet_vector: [Ω, κ, β, H, axioms...]        │
│  ├── content_hash: sha256                        │
│  └── metadata: {type, timestamp, dependencies}   │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│              UET Tensorizer                      │
│  Input: any file from research_uet/             │
│  Process:                                        │
│  1. Extract imports → dependency graph           │
│  2. Run UET engine → compute Ω, κ, β            │
│  3. Detect axiom references → 12-bit signature   │
│  4. Compute Shannon entropy H                    │
│  5. Output: UET vector (fixed-size)              │
│                                                  │
│  Uses: research_uet.core.uet_master_equation    │
│  NOT ad-hoc math — delegates to real engine      │
└─────────────────────────────────────────────────┘
```

---

## 4. Rust Compatibility

### ที่ต้องรู้
- Rust ใช้อยู่แล้วใน `0.18_Mathnicry/rust_miner/` (tokio + wgpu + rayon + serde)
- โครงการจะย้ายไป Rust ทั้งหมดในอนาคต แต่ยังไม่ใช่ตอนนี้

### กฎออกแบบ
1. **Data structures = Rust-compatible:** ใช้ fixed-size arrays, structs ที่ map ไป `#[repr(C)]` ได้
2. **Serialization = serde-compatible:** JSON/MessagePack ที่ Rust serde อ่านได้
3. **No Python-only tricks:** ไม่ใช้ pickle, ไม่ใช้ dynamic typing ใน stored data
4. **Core algorithm แยกชัด:** ถ้าวันหลังจะเขียน Rust ใหม่ ต้องรู้ว่า algorithm อยู่ตรงไหน

```rust
// ตัวอย่าง: struct ที่ Rust จะใช้ในอนาคต
#[derive(Serialize, Deserialize)]
struct UetVector {
    omega: f64,
    kappa: f64,
    beta: f64,
    entropy: f64,
    axiom_signature: [bool; 12],
    topic_id: String,
    content_hash: [u8; 32],
}
```

Python version ต้องสร้าง data ในรูปแบบเดียวกัน:
```python
@dataclass
class UetVector:
    omega: float
    kappa: float
    beta: float
    entropy: float
    axiom_signature: list[bool]  # len=12
    topic_id: str
    content_hash: bytes  # 32 bytes
```

---

## 5. ขั้นตอนการทำงาน (Step-by-step สำหรับ Session หน้า)

### Step 1: สร้าง UET Tensorizer (1 ไฟล์)
- อ่านไฟล์จาก `research_uet/topics/`
- ใช้ `uet_master_equation.py` คำนวณ Ω, κ, β จริงๆ
- Output = `UetVector` struct
- **ทดสอบกับ 1 topic ก่อน** แล้วคุยกันว่า vector ถูกต้องไหม

### Step 2: สร้าง Vector Store (1 ไฟล์)
- เริ่มจาก SQLite + numpy (ไม่ต้องติดตั้ง package ใหม่)
- Schema: `(id, topic_id, file_path, uet_vector BLOB, metadata JSON)`
- CRUD operations: insert, search_by_omega, search_by_topic

### Step 3: สร้าง Ω-Search Engine (1 ไฟล์)
- Input: query parameters (Ω range, topic, axioms)
- Process: compute Ω-distance between query and all indexed vectors
- Output: ranked list of matching research items

### Step 4: สร้าง Indexer/CLI (1 ไฟล์)
- Scan `research_uet/topics/` → tensorize all files → store in DB
- CLI: `python -m research_uet.vectordb index` / `python -m research_uet.vectordb search "query"`

### Step 5: ทดสอบ Cross-topic Search
- Query: "find all topics related to Topic 0.0 Grand Unification"
- Verify: coupling matrix βᵢⱼ gives correct topic relationships

---

## 6. ข้อควรระวัง

1. **Disk เหลือ ~2.5 MB** — ต้อง free space ก่อน หรือใช้ SQLite (ไม่ต้องติดตั้ง)
2. **ทำทีละขั้น** — สร้าง 1 module → ทดสอบ → คุย → แล้วค่อยต่อ
3. **ใช้ engine จริง** — delegate ไป `uet_master_equation.py` ไม่ใช่เขียน math เอง
4. **ห้ามประดิษฐ์ format ขึ้นมาเอง** — vector dimensions ต้องมีเหตุผลทาง physics
5. **ข้อมูลเก่าใน `ทองข้อมูลดี/`** — ใช้อ้างอิงได้ แต่ห้ามใช้เป็น design spec
