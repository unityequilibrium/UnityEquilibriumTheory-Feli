# เอกสารสถาปัตยกรรมซอฟต์แวร์: UET Platform

## 1. บทนำ (Introduction)

เอกสารสถาปัตยกรรมฉบับนี้จัดทำขึ้นเพื่อเป็นแหล่งข้อมูลอ้างอิงหลัก (Single Source of Truth) สำหรับสถาปนิก, วิศวกร, และผู้จัดการผลิตภัณฑ์ ในการทำความเข้าใจ, พัฒนา, และบำรุงรักษาระบบ UET Platform อย่างเป็นระบบ วัตถุประสงค์หลักของเอกสารคือการนำเสนอภาพรวมเชิงลึกของโครงสร้างสถาปัตยกรรม, หลักการออกแบบ, การทำงานร่วมกันของระบบย่อย, สถาปัตยกรรมข้อมูล, และแนวทางการนำไปใช้งานจริง (Deployment)

เป้าหมายระดับสูงของ UET Platform คือการสร้างแพลตฟอร์มที่สามารถรองรับการขยายตัวในระดับโลก (Global-Scale) สำหรับการจัดการองค์ความรู้ (Knowledge Management), การทำงานของ AI Agents, และการบริหารจัดการโครงการ (Projects) จำนวนมากได้อย่างมีเสถียรภาพและประสิทธิภาพสูงสุด สถาปัตยกรรมที่นำเสนอในเอกสารนี้จึงถูกออกแบบมาเพื่อความทนทาน, ความสามารถในการขยายขนาด, และความง่ายต่อการดูแลรักษาในระยะยาว

เอกสารฉบับนี้จะนำเสนอเนื้อหาตามลำดับดังต่อไปนี้:

- **หลักการและเหตุผลเชิงสถาปัตยกรรม:** อธิบายถึงปรัชญาและกฎเกณฑ์ที่ใช้ในการตัดสินใจทางเทคนิคทั้งหมด
- **ภาพรวมสถาปัตยกรรมระบบ:** แนะนำโครงสร้างสถาปัตยกรรมแบบ 5 ชั้น (5-Layer Architecture)
- **ระบบย่อยหลักและการทำงานร่วมกัน:** เจาะลึกถึงกลไกการทำงานของระบบกำกับดูแลและระบบอัจฉริยะ
- **สถาปัตยกรรมข้อมูลและ Schema:** แสดงโครงสร้างตารางข้อมูลและ Entity ที่สำคัญ
- **โฟลว์การทำงานเชิงสถาปัตยกรรมที่สำคัญ:** ยกตัวอย่างลำดับการทำงานแบบ End-to-End
- **ประเด็นร่วมเชิงสถาปัตยกรรม:** อธิบายระบบสนับสนุนที่ทำงานครอบคลุมทุกส่วน เช่น ความปลอดภัยและการแคช
- **สถาปัตยกรรมการนำไปใช้งาน:** สรุปแนวทางการนำระบบขึ้นใช้งานจริงและการขยายขนาด

--------------------------------------------------------------------------------

## 2. หลักการและเหตุผลเชิงสถาปัตยกรรม (Architectural Principles & Rationale)

การมีหลักการเชิงสถาปัตยกรรมที่ชัดเจนเป็นหัวใจสำคัญของการพัฒนาระบบที่ซับซ้อน หลักการเหล่านี้ทำหน้าที่เป็น "รัฐธรรมนูญ" ของระบบ ซึ่งเป็นแนวทางในการตัดสินใจทางเทคนิคทั้งหมด ตั้งแต่การเลือกใช้เทคโนโลยีไปจนถึงการออกแบบการทำงานร่วมกันของแต่ละโมดูล เพื่อให้แน่ใจว่า UET Platform จะมีความเสถียร, สามารถขยายขนาดได้, และง่ายต่อการดูแลรักษาในระยะยาว

หลักการออกแบบหลัก 4 ข้อของ UET Platform มีดังนี้:

- **เสถียรภาพมาก่อนคุณสมบัติใหม่ (Stability over Features)** ระบบให้ความสำคัญกับความเสถียรในสภาพแวดล้อมการใช้งานจริง (Production) เป็นอันดับแรก การตัดสินใจเลือกใช้เทคโนโลยีเวอร์ชันที่มีการสนับสนุนระยะยาว (Long-Term Support - LTS) เช่น Next.js 15 LTS เป็นเครื่องยืนยันถึงหลักการนี้ **เพราะเราต้องการสร้างรากฐานที่มั่นคงและหลีกเลี่ยงปัญหาที่เกิดจากการเปลี่ยนแปลง API ที่เกิดขึ้นบ่อยในเวอร์ชันใหม่ ๆ ซึ่งอาจส่งผลกระทบต่อความเสถียรของทั้งระบบ**
- **สถาปัตยกรรมที่ขับเคลื่อนด้วยอีเวนต์ (Event-Driven Architecture)** ระบบถูกออกแบบให้ Event Bus ทำหน้าที่เปรียบเสมือนระบบประสาทส่วนกลาง (Central Nervous System) วิธีการนี้ช่วยลดการพึ่งพิงระหว่างโมดูล (Decoupling) **ซึ่งเป็นสิ่งสำคัญอย่างยิ่งสำหรับระบบขนาดใหญ่นี้ สิ่งนี้ช่วยให้ทีมที่ทำงานแยกกันสามารถนำการอัปเดตไปใช้กับบริการต่าง ๆ เช่น Agent Engine ได้โดยไม่จำเป็นต้องมีการเปิดตัว App Layer ที่สอดคล้องกัน ซึ่งช่วยเพิ่มความเร็วในการพัฒนาและลดความเสี่ยงในการนำไปใช้งานได้อย่างมาก**
- **นโยบายปลอดข้อมูลเก่า (Zero-Stale Policy)** ความถูกต้องขององค์ความรู้คือสิ่งสำคัญสูงสุด สถาปัตยกรรมจึงบังคับใช้นโยบายที่เข้มงวดว่าทุกโมดูลจะต้องทำงานกับข้อมูลเวอร์ชันล่าสุดเสมอ โดยมี **Knowledge Registry** ทำหน้าที่เป็นแหล่งอ้างอิงความจริงเพียงแหล่งเดียว (Single Source of Truth) **การบังคับใช้นี้ทำให้แน่ใจได้ว่า AI Agents จะไม่สร้างผลลัพธ์จากข้อมูลที่ล้าสมัย ซึ่งเป็นความเสี่ยงหลักในระบบที่ขับเคลื่อนด้วยข้อมูล**
- **พฤติกรรมที่คาดเดาได้ (Deterministic Behavior)** ทุกโมดูลในระบบ ตั้งแต่ Agent Engine จนถึง Knowledge Sync Engine ถูกออกแบบมาให้ทำงานอย่างคาดเดาผลลัพธ์ได้ 100% กล่าวคือ เมื่อได้รับ Input แบบเดิม ผลลัพธ์ที่ได้จะต้องเหมือนเดิมทุกครั้ง **หลักการนี้มีความสำคัญอย่างยิ่งต่อการทดสอบระบบอัตโนมัติ, การตรวจสอบย้อนกลับ (Traceability), และการรับประกันความน่าเชื่อถือของผลลัพธ์ที่ได้จาก AI Agent ซึ่งเป็นสิ่งจำเป็นสำหรับแพลตฟอร์มระดับองค์กร**

หลักการทั้งสี่ข้อนี้ได้ส่งผลโดยตรงต่อการเลือกใช้โครงสร้างสถาปัตยกรรมแบบ 5 ชั้น ซึ่งจะอธิบายอย่างละเอียดในหัวข้อถัดไป เพื่อให้การแบ่งแยกความรับผิดชอบและการทำงานร่วมกันของระบบเป็นไปอย่างมีระเบียบและสอดคล้องกับปรัชญาการออกแบบหลัก

--------------------------------------------------------------------------------

## 3. ภาพรวมสถาปัตยกรรมระบบ (System Architecture Overview)

สถาปัตยกรรมหลักของ UET Platform ถูกออกแบบโดยใช้โครงสร้างแบบ 5 ชั้น (5-Layer Architecture) ซึ่งเป็นรูปแบบมาตรฐานที่องค์กรขนาดใหญ่นิยมใช้ในการพัฒนาระบบที่ซับซ้อนและต้องการความสามารถในการขยายขนาดสูง การแบ่งสถาปัตยกรรมออกเป็นชั้นต่าง ๆ ช่วยให้เกิดการแยกความรับผิดชอบ (Separation of Concerns) อย่างชัดเจน ทำให้ทีมสามารถพัฒนา, ทดสอบ, และบำรุงรักษาส่วนต่าง ๆ ของระบบได้อย่างอิสระโดยมีผลกระทบต่อกันน้อยที่สุด

### 3.1 App Layer (Frontend UI)

ชั้นนี้รับผิดชอบการแสดงผลส่วนต่อประสานกับผู้ใช้ (User Interface) ทั้งหมด เป็นจุดที่ผู้ใช้โต้ตอบกับระบบโดยตรง บทบาทหลักคือการนำเสนอข้อมูลและรับคำสั่งจากผู้ใช้เพื่อส่งต่อไปยังชั้น Backend

- **หน้าที่หลัก:** แสดงผล UI ทั้งหมด, จัดการ Workspace แบบ 3-Panel (Source / Chat / Studio), แสดงผลไฟล์ Markdown, และส่งคำสั่งของผู้ใช้ไปยัง API Layer
- **เทคโนโลยีหลัก:** **Next.js 15 LTS (App Router)** เพื่อความเสถียรสูงสุดในระดับ Production

### 3.2 API Layer (Backend Services)

ชั้นนี้เป็นประตูสู่บริการทั้งหมดของระบบ ทำหน้าที่รับคำขอ (Request) จาก App Layer, ตรวจสอบสิทธิ์, และส่งต่อไปยังบริการที่เกี่ยวข้อง โครงสร้างภายในเป็นแบบ Service Modules ที่แบ่งบริการย่อยออกจากกันอย่างชัดเจนเพื่อความเป็นอิสระในการพัฒนาและปรับขนาด

- **โครงสร้าง:** แบ่งออกเป็นบริการย่อย (Service Modules) ที่ทำงานแยกจากกัน:
    - **Authentication Service:** จัดการการเข้าสู่ระบบ, JWT, และระบบ Role (Guest, Member, Power User, Admin)
    - **Project Service:** จัดการ CRUD สำหรับโปรเจกต์และสมาชิกในโปรเจกต์
    - **Knowledge Base Service (Global KB):** จัดการคลังความรู้ส่วนกลาง, ไฟล์, และเวอร์ชัน
    - **Project Knowledge Service (Local KB):** จัดการคลังความรู้แยกตามโปรเจกต์ พร้อม Vector Embeddings ของแต่ละโปรเจกต์
    - **Token & Finance Service:** บริหารจัดการระบบเครดิต (UC) และโทเค็น (AT)
    - **File Processor Service:** สกัดข้อความจากไฟล์ประเภทต่าง ๆ เช่น PDF, Docx
    - **Graph Engine Service:** จัดการและวิเคราะห์ความสัมพันธ์ของข้อมูลในรูปแบบ Node/Edge

### 3.3 AI Layer (RAG / Vector / Agents)

ชั้นนี้เปรียบเสมือน "สมอง" ของ UET Platform รับผิดชอบการทำงานที่เกี่ยวข้องกับปัญญาประดิษฐ์ทั้งหมด ตั้งแต่การค้นหาและดึงองค์ความรู้ไปจนถึงการคิดวิเคราะห์และประมวลผลเชิงตรรกะ

- **หน้าที่หลัก:** จัดการกระบวนการ Retrieval-Augmented Generation (RAG) เพื่อดึงข้อมูลที่เกี่ยวข้องจาก Vector DB, จัดการ Vector Embeddings, และเป็นที่ทำงานของ Agent Engine ซึ่งทำหน้าที่วิเคราะห์ วางแผน และดำเนินการตามคำสั่ง
- **ความสำคัญ:** เป็นชั้นที่สร้างความแตกต่างและความสามารถหลักให้กับแพลตฟอร์ม

### 3.4 Data Layer (DB / File / Versioning)

ชั้นนี้รับผิดชอบการจัดเก็บและบริหารจัดการข้อมูลทั้งหมดของแพลตฟอร์ม ถูกออกแบบมาเพื่อรองรับการควบคุมเวอร์ชันและความถูกต้องของข้อมูลอย่างเข้มงวด

- **หน้าที่หลัก:** จัดเก็บข้อมูลที่มีโครงสร้างในรูปแบบตาราง (Relational Database), จัดเก็บไฟล์ดิบ (File Storage), ควบคุมเวอร์ชันขององค์ความรู้ (Git-style versioning), และบันทึก Log การทำงานและข้อผิดพลาดทั้งหมด **แนวทางนี้ทำให้มั่นใจได้ว่าทุกการเปลี่ยนแปลงในคลังความรู้จะเป็นแบบ Atomic และสามารถตรวจสอบย้อนกลับได้ คล้ายกับ Code Repository ทำให้สามารถย้อนกลับ (Rollback) และมีประวัติการตรวจสอบการเปลี่ยนแปลงขององค์ความรู้ได้อย่างสมบูรณ์**
- **เทคโนโลยีหลัก:** **PostgreSQL** สำหรับข้อมูลตาราง, Vector DB สำหรับ Embeddings, และ File Storage สำหรับไฟล์ดิบ

### 3.5 Infrastructure Layer (Deployment / Scaling)

ชั้นนี้เป็นรากฐานที่สนับสนุนให้ทั้ง 4 ชั้นข้างต้นทำงานได้อย่างราบรื่น มีเสถียรภาพ และพร้อมใช้งานตลอดเวลา

- **หน้าที่หลัก:** จัดการการนำระบบขึ้นใช้งาน (Deployment), การขยายขนาดระบบ (Scaling) เพื่อรองรับผู้ใช้จำนวนมาก, การดูแลความพร้อมใช้งานของระบบ (High Availability), และการสำรองข้อมูล
- **แนวทาง:** ออกแบบให้รองรับการทำงานบน Container (Docker) และสามารถขยายขนาด Worker Pool สำหรับงานประมวลผลหนักได้

การแบ่งสถาปัตยกรรมออกเป็น 5 ชั้นที่ชัดเจนนี้ เป็นรากฐานสำคัญที่ทำให้ระบบย่อยหลักสามารถทำงานร่วมกันได้อย่างมีประสิทธิภาพ ซึ่งจะถูกอธิบายอย่างละเอียดในหัวข้อถัดไป

--------------------------------------------------------------------------------

## 4. ระบบย่อยหลักและการทำงานร่วมกัน (Core Subsystems & Interactions)

แม้ว่าสถาปัตยกรรมโดยรวมจะถูกแบ่งออกเป็น 5 ชั้น แต่หัวใจที่แท้จริงของ UET Platform คือการทำงานร่วมกันอย่างลงตัวระหว่าง "ระบบกำกับดูแล" (Governance Systems) ซึ่งทำหน้าที่ควบคุมกฎระเบียบและความถูกต้อง และ "ระบบย่อยอัจฉริยะ" (Intelligent Subsystems) ซึ่งรับผิดชอบการประมวลผลเชิงตรรกะ ทั้งสองส่วนนี้ทำงานประสานกันผ่าน Event Bus เพื่อให้แพลตฟอร์มทำงานได้อย่างสอดคล้องและคาดเดาได้

### 4.1 ระบบกำกับดูแล (Governance Systems)

ระบบกลุ่มนี้ทำหน้าที่เป็นผู้คุมกฎสูงสุดของแพลตฟอร์ม เพื่อรับประกันว่าทุกโมดูลจะทำงานภายใต้กรอบที่กำหนดไว้อย่างเคร่งครัด

#### 4.1.1 SYSTEM_CONTRACT

`SYSTEM_CONTRACT` เปรียบเสมือน **"รัฐธรรมนูญของระบบ"** ที่กำหนดกฎเหล็กสูงสุดซึ่งทุกโมดูลต้องปฏิบัติตามโดยไม่มีข้อยกเว้น กฎเหล่านี้ถูกสร้างขึ้นจากหลักการเชิงสถาปัตยกรรมหลัก เช่น:

- **Zero-Stale Policy:** บังคับให้ทุกโมดูลต้องตรวจสอบเวอร์ชันองค์ความรู้กับ Knowledge Registry ก่อนทำงานเสมอ
- **Deterministic Behavior:** กำหนดให้ทุกการทำงานต้องคาดเดาผลลัพธ์ได้เมื่อได้รับ Input เดิม
- **Event-First Architecture:** กำหนดให้การเปลี่ยนแปลงสถานะที่สำคัญต้องประกาศผ่าน Event Bus เท่านั้น `SYSTEM_CONTRACT` คือกลไกที่รับประกันความสอดคล้องและความน่าเชื่อถือของทั้งแพลตฟอร์ม

#### 4.1.2 FLOW_CONTROL

`FLOW_CONTROL` ทำหน้าที่เป็น **"ด่านตรวจ"** ที่บังคับให้ทุกคำขอ (Request) ที่เข้ามาในระบบต้องดำเนินการตามลำดับขั้นตอนที่ถูกต้องและปลอดภัยเสมอ ตัวอย่างเช่น คำขอจากผู้ใช้จะต้องผ่านกระบวนการ **Validate → Authorize → Route → Execute** ตามลำดับ ตัวอย่างเช่น คำขอแก้ไขไฟล์ของผู้ใช้จะต้องถูก **Validate** เพื่อตรวจสอบรูปแบบที่ถูกต้องก่อน จากนั้นจึง **Authorize** กับ `PERMISSION_MATRIX` แล้ว **Route** ไปยัง File Processor Service และสุดท้ายจึง **Execute** `FLOW_CONTROL` จะป้องกันไม่ให้มีการข้ามขั้นตอนใด ๆ ซึ่งอาจนำไปสู่ช่องโหว่ด้านความปลอดภัยหรือการทำงานที่ผิดพลาด

#### 4.1.3 EVENT_BUS

`EVENT_BUS` คือ **"ระบบสื่อสารกลาง"** ของแพลตฟอร์มทั้งหมด ทำหน้าที่ประกาศเหตุการณ์สำคัญเพื่อให้ทุกส่วนของระบบรับรู้และปรับสถานะตามความเป็นจริงพร้อมกัน ตัวอย่างอีเวนต์ที่สำคัญได้แก่:

- `KB_VERSION_UPDATED`: ประกาศเมื่อองค์ความรู้มีเวอร์ชันใหม่
- `CACHE_INVALIDATED`: ประกาศเพื่อสั่งให้ระบบ Cache ทำการล้างข้อมูลเก่า การใช้ `EVENT_BUS` ทำให้ UI, Cache Layer, และ Agents สามารถอัปเดตตัวเองให้สอดคล้องกับสถานะล่าสุดของระบบได้โดยอัตโนมัติ ซึ่งเป็นหัวใจของสถาปัตยกรรมที่ขับเคลื่อนด้วยอีเวนต์

### 4.2 ระบบย่อยอัจฉริยะ (Intelligent Subsystems)

ระบบกลุ่มนี้คือส่วนที่ทำการประมวลผลและสร้างความสามารถหลักให้กับแพลตฟอร์ม

#### 4.2.1 Knowledge Sync Engine (KS)

KS Engine คือหัวใจสำคัญที่ทำให้แพลตฟอร์มมี "ความรู้ที่เป็นปัจจุบัน" อยู่เสมอ โดยมีหน้าที่รับผิดชอบกระบวนการที่สำคัญในการแปลงไฟล์ดิบที่ไม่มีโครงสร้าง **(L0)** ให้กลายเป็นองค์ความรู้ที่มีโครงสร้าง มีเวอร์ชัน และมีความหมายทางซีแมนติก **(L1-L5)** ซึ่งเกี่ยวข้องกับไปป์ไลน์ที่กำหนดไว้แน่นอนของการกำหนดเวอร์ชัน, การแบ่งส่วน, การฝัง และสุดท้ายคือการอัปเดต Knowledge Registry หลังจากกระบวนการเสร็จสิ้น KS Engine จะประกาศอีเวนต์ `KB_VERSION_UPDATED` ผ่าน `EVENT_BUS`

#### 4.2.2 Retrieval-Augmented Generation (RAG) Engine

RAG Engine ทำหน้าที่ดึงองค์ความรู้ที่เกี่ยวข้องที่สุดจาก Vector DB เพื่อสนับสนุนการทำงานของ Agent ก่อนที่จะทำการค้นหาทุกครั้ง RAG Engine **ต้องตรวจสอบเวอร์ชันขององค์ความรู้กับ Knowledge Registry เสมอ** เพื่อบังคับใช้ **"Zero-Stale Policy"** อย่างเคร่งครัด ทำให้มั่นใจได้ว่าข้อมูลที่ Agent ได้รับจะเป็นข้อมูลที่สดใหม่และถูกต้องที่สุดเสมอ

#### 4.2.3 Agent Engine

Agent Engine คือ **"สมอง"** ที่ทำหน้าที่คิดวิเคราะห์, วางแผน, และดำเนินการตามลำดับขั้นตอนที่คาดเดาได้ (Deterministic Flow) การทำงานของ Agent จะต้องพึ่งพาข้อมูลที่ได้รับจาก RAG Engine และต้องปฏิบัติตามกฎที่กำหนดไว้ใน `SYSTEM_CONTRACT` อย่างเคร่งครัด เพื่อให้ผลลัพธ์มีความน่าเชื่อถือและสามารถตรวจสอบย้อนกลับได้

การทำงานที่ซับซ้อนและประสานกันอย่างลงตัวของระบบย่อยเหล่านี้ จำเป็นต้องอาศัยโครงสร้างข้อมูลที่ถูกออกแบบมาอย่างดี ซึ่งจะอธิบายอย่างละเอียดในหัวข้อถัดไป

--------------------------------------------------------------------------------

## 5. สถาปัตยกรรมข้อมูลและ Schema (Data Architecture & Schema)

สถาปัตยกรรมข้อมูลของ UET Platform ถูกออกแบบมาเพื่อรองรับ **"วัฏจักรของความรู้" (Knowledge Evolution Cycle)** โดยมีหลักการสำคัญคือ ทุกองค์ประกอบของข้อมูลจะต้องมีการควบคุมเวอร์ชัน, สามารถตรวจสอบย้อนกลับได้ (Traceable), และเชื่อมโยงกันอย่างเป็นระบบ เพื่อสร้างรากฐานข้อมูลที่แข็งแกร่งและน่าเชื่อถือสำหรับระบบ AI

ตารางด้านล่างสรุป Entity หลักใน `DATA_SCHEMA v3.0` และบทบาทของแต่ละ Entity ในระบบนิเวศข้อมูล:

|   |   |
|---|---|
|Entity|Description (คำอธิบายบทบาท)|
|**USER & PROJECT**|**ผู้ใช้และพื้นที่ทำงาน:** เป็นขอบเขตหลัก (Scope) ของข้อมูลทั้งหมด ผู้ใช้แต่ละคนสามารถมีได้หลายโปรเจกต์ และโปรเจกต์เป็นพื้นที่สำหรับจัดเก็บองค์ความรู้และทรัพยากรที่เกี่ยวข้อง|
|**FILE & FILE_VERSION**|**ไฟล์ดิบและการควบคุมเวอร์ชัน:** จัดเก็บไฟล์ต้นฉบับที่ผู้ใช้อัปโหลด ทุกครั้งที่มีการแก้ไข จะมีการสร้างเวอร์ชันใหม่ (New Version) เพื่อให้สามารถย้อนกลับไปดูประวัติการเปลี่ยนแปลงได้เสมอ|
|**CHUNK & EMBEDDING**|**หน่วยย่อยของความรู้และเวกเตอร์:** `CHUNK` คือหน่วยข้อมูลที่เล็กที่สุดที่ได้จากการแบ่งเนื้อหาของไฟล์ `EMBEDDING` คือค่าเวกเตอร์ที่แทนความหมายของแต่ละ Chunk ซึ่งจำเป็นสำหรับ RAG|
|**KNOWLEDGE REGISTRY**|**ทะเบียนองค์ความรู้:** เป็น Entity ที่สำคัญที่สุด ทำหน้าที่เป็น **Single Source of Truth** สำหรับเวอร์ชันล่าสุดขององค์ความรู้ (`kb_version`) และเวอร์ชันของเวกเตอร์ (`vector_version`)|
|**AGENT_RUN & ROUTING_LOG**|**บันทึกการทำงานของ Agent:** บันทึกทุกขั้นตอนการทำงานของ Agent รวมถึงโมเดลที่เลือก (`ROUTING_LOG`), โทเค็นที่ใช้, และสถานะ สิ่งนี้ให้ความโปร่งใส 100% และจำเป็นสำหรับการดีบักและตรวจสอบพฤติกรรมของ AI|
|**EVENT_LOG & ERROR_LOG**|**บันทึกเหตุการณ์และข้อผิดพลาด:** บันทึกทุกเหตุการณ์สำคัญที่เกิดขึ้นใน Event Bus และบันทึกข้อผิดพลาดทั้งหมด เพื่อใช้ในการตรวจสอบและแก้ไขปัญหาระบบ|
|**CACHE_ENTRY & METRICS**|**แคชและตัวชี้วัดประสิทธิภาพ:** `CACHE_ENTRY` จัดเก็บข้อมูลแคชเพื่อเพิ่มความเร็วในการตอบสนอง `METRICS` จัดเก็บตัวชี้วัดประสิทธิภาพของระบบในด้านต่าง ๆ เช่น Latency, RAG Precision|

**ความสัมพันธ์ที่สำคัญระหว่าง Entity:**

- `Project` มีได้หลาย `File`
- `File` มีได้หลาย `File_Version`
- `File_Version` ถูกแบ่งออกเป็นหลาย `Chunk`
- `Chunk` มี `Embedding` ได้เพียง 1 เดียว
- `Knowledge Registry` อ้างอิงถึง `File_Version` ล่าสุดของทุกไฟล์ในโปรเจกต์

โครงสร้าง Schema ที่รัดกุมนี้เป็นพื้นฐานสำคัญที่ทำให้โฟลว์การทำงานต่าง ๆ ของระบบสามารถดำเนินการได้อย่างถูกต้องและมีประสิทธิภาพ ซึ่งจะแสดงให้เห็นภาพชัดเจนยิ่งขึ้นในหัวข้อถัดไป

--------------------------------------------------------------------------------

## 6. โฟลว์การทำงานเชิงสถาปัตยกรรมที่สำคัญ (Key Architectural Workflows)

เพื่อให้เห็นภาพว่าสถาปัตยกรรมและโมดูลต่าง ๆ ที่ได้อธิบายไปข้างต้นทำงานประสานกันอย่างไรในทางปฏิบัติ หัวข้อนี้จะนำเสนอตัวอย่างลำดับการทำงานแบบ End-to-End ใน 2 สถานการณ์ที่สำคัญที่สุดของแพลตฟอร์ม: การนำเข้าองค์ความรู้ และการตอบคำถามโดย Agent

### 6.1 โฟลว์การนำเข้าและซิงค์องค์ความรู้ (Knowledge Ingestion & Sync Flow)

โฟลว์นี้จะเกิดขึ้นเมื่อผู้ใช้หรือ Agent ทำการอัปโหลดหรือแก้ไขไฟล์ ซึ่งเป็นการเริ่มต้นวัฏจักรขององค์ความรู้ใหม่

1. **ผู้ใช้/Agent แก้ไขหรืออัปโหลดไฟล์ (App Layer / Agent Engine):** ผู้ใช้ทำการเปลี่ยนแปลงไฟล์ผ่าน UI หรือ Agent ทำการสร้างไฟล์ใหม่
2. **API Layer รับไฟล์:** API Layer รับไฟล์และข้อมูลที่เกี่ยวข้อง แล้วส่งต่อไปยัง **Knowledge Sync Engine (KS)** เพื่อเริ่มกระบวนการซิงค์
3. **KS Engine ประมวลผลไฟล์:** KS Engine ทำการตรวจสอบ Hash ของไฟล์, สร้าง `File_Version` ใหม่, แบ่งเนื้อหาออกเป็น `Chunk`, และสร้าง `Embedding` สำหรับแต่ละ Chunk
4. **KS Engine อัปเดตฐานข้อมูล:** KS Engine นำ Embedding ที่ได้ไปจัดเก็บใน Vector DB และที่สำคัญที่สุดคือการอัปเดต **Knowledge Registry** โดยเพิ่มหมายเลข `kb_version` ขึ้นไปอีกหนึ่งระดับ
5. **KS Engine ประกาศอีเวนต์:** KS Engine ประกาศอีเวนต์ `KB_VERSION_UPDATED` ผ่าน **Event Bus** เพื่อแจ้งให้ทั้งระบบทราบว่าองค์ความรู้มีการเปลี่ยนแปลง
6. **Cache Layer ทำการล้าง Cache:** ระบบ Cache ที่รับฟังอีเวนต์นี้จะทำการล้างข้อมูลแคชที่เกี่ยวข้องกับไฟล์นั้นทิ้งไป (Cache Invalidation) เพื่อบังคับใช้ Zero-Stale Policy
7. **UI รีเฟรชข้อมูล:** App Layer (UI) รับอีเวนต์เดียวกันและทำการรีเฟรชข้อมูลไฟล์เพื่อให้ผู้ใช้เห็นการเปลี่ยนแปลงล่าสุด

### 6.2 โฟลว์การตอบคำถามด้วย Agent และ RAG (Agent Reasoning & RAG Query Flow)

โฟลว์นี้แสดงกระบวนการคิดและตอบคำถามของ Agent โดยอาศัยองค์ความรู้ล่าสุดจาก RAG

1. **ผู้ใช้ส่งคำถาม (App Layer):** ผู้ใช้พิมพ์คำถามผ่าน Chat Panel บน UI
2. **API Layer รับคำขอและส่งต่อ:** API Layer รับคำขอและส่งต่อไปยัง **Flow Control**
3. **Flow Control ตรวจสอบและส่งต่อ:** Flow Control ทำการตรวจสอบสิทธิ์และลำดับความถูกต้อง จากนั้นจึงส่งคำขอไปยัง **Agent Engine**
4. **Agent Engine วิเคราะห์คำถาม:** Agent Engine วิเคราะห์คำถามและตัดสินใจว่าจำเป็นต้องใช้ข้อมูลสนับสนุนจาก RAG เพื่อตอบคำถามนี้
5. **Agent Engine เรียกใช้ RAG:** Agent Engine ส่งคำค้นหา (Query) ไปยัง **RAG Engine** พร้อมระบุ `kb_version` ล่าสุดที่ตนเองรับรู้ เพื่อเป็นการยืนยันว่าต้องการข้อมูลที่สดใหม่
6. **RAG Engine ค้นหาข้อมูล:** RAG Engine ตรวจสอบ `kb_version` ที่ได้รับกับ **Knowledge Registry** หากตรงกันจึงทำการค้นหาข้อมูลที่เกี่ยวข้องจาก Vector DB
7. **RAG Engine สร้าง "EvidenceSet":** RAG Engine รวบรวมข้อมูลที่ค้นพบและสร้างเป็นชุดหลักฐาน (EvidenceSet) ส่งกลับไปให้ Agent Engine
8. **Agent Engine ประมวลผลและสร้างคำตอบ:** Agent Engine ใช้ EvidenceSet ที่ได้รับมาเป็นพื้นฐานในการประมวลผลเชิงตรรกะและสร้างคำตอบที่ถูกต้องและอ้างอิงได้
9. **Agent Engine ส่งคำตอบกลับ:** คำตอบสุดท้ายถูกส่งกลับไปยัง UI ผ่าน API Layer เพื่อแสดงผลให้ผู้ใช้เห็น

การทำงานที่ราบรื่นของโฟลว์เหล่านี้จำเป็นต้องอาศัยระบบสนับสนุนที่แข็งแกร่ง เช่น ระบบความปลอดภัย, การแคช, และการจัดการข้อผิดพลาด ซึ่งเป็นประเด็นร่วมที่จะกล่าวถึงต่อไป

--------------------------------------------------------------------------------

## 7. ประเด็นร่วมเชิงสถาปัตยกรรม (Cross-Cutting Concerns)

นอกเหนือจากระบบหลักและโฟลว์การทำงานที่สำคัญแล้ว UET Platform ยังประกอบด้วยระบบสนับสนุนที่ทำงานครอบคลุมทุกส่วนของสถาปัตยกรรม (Cross-Cutting) เพื่อรับประกันความปลอดภัย, ประสิทธิภาพ, และความน่าเชื่อถือของแพลตฟอร์มโดยรวม

### 7.1 ความปลอดภัยและสิทธิ์การเข้าถึง (Security & Permissions)

ความปลอดภัยเป็นสิ่งสำคัญสูงสุด ระบบใช้รูปแบบการควบคุมสิทธิ์การเข้าถึงตามบทบาท (Role-Based Access Control - RBAC) โดยแบ่งผู้ใช้ออกเป็น 4 ระดับหลัก: **Guest, Member, Power User, และ Admin** แต่ละบทบาทจะมีสิทธิ์ในการกระทำ (Action) ที่แตกต่างกันอย่างชัดเจน การควบคุมนี้ถูกกำกับดูแลโดย **PERMISSION_MATRIX** ซึ่งทำหน้าที่เป็นตารางอ้างอิงสำหรับตรวจสอบสิทธิ์ในทุกระดับ ตั้งแต่การเรียกใช้ API, การเข้าถึง Knowledge Base, ไปจนถึงการสั่งงาน Agent

### 7.2 กลยุทธ์การแคช (Caching Strategy)

เพื่อเพิ่มประสิทธิภาพและลดภาระการทำงานของระบบ UET Platform ใช้กลยุทธ์การแคชแบบหลายชั้น (Multi-layered Caching) ที่สำคัญที่สุดคือระบบแคชนี้ถูกออกแบบให้เป็นแบบ **ขับเคลื่อนด้วยอีเวนต์ (Event-Driven)** โดยผูกการทำงานกับการเปลี่ยนแปลงของ `kb_version` ใน Knowledge Registry เมื่อใดก็ตามที่มีการประกาศอีเวนต์ `KB_VERSION_UPDATED` ระบบแคชจะทำการล้างข้อมูลที่เกี่ยวข้องทิ้งทันที (Cache Invalidation) ซึ่งเป็นการบังคับใช้ **"Zero-Stale Policy"** อย่างเข้มงวดและรับประกันว่าผู้ใช้และ Agent จะได้ใช้ข้อมูลที่สดใหม่อยู่เสมอ

### 7.3 การจัดการข้อผิดพลาด (Error Handling)

ระบบมีการจัดการข้อผิดพลาดที่เป็นมาตรฐานและรวมศูนย์ เพื่อให้การติดตามและแก้ไขปัญหาทำได้ง่าย ข้อผิดพลาดทั้งหมดถูกจำแนกออกเป็นประเภทที่ชัดเจน เช่น **USER_ERROR, SYSTEM_ERROR, API_ERROR, AGENT_ERROR, และ DATA_ERROR** วงจรชีวิตของข้อผิดพลาด (Error Lifecycle) จะเริ่มต้นตั้งแต่การตรวจจับ, การสร้าง Object ข้อผิดพลาดที่เป็นมาตรฐาน, การส่งอีเวนต์ผ่าน Event Bus, ไปจนถึงการบันทึกลงใน **ERROR_LOG** เพื่อให้สามารถตรวจสอบย้อนหลังได้

ระบบสนับสนุนเหล่านี้เป็นส่วนประกอบที่สำคัญซึ่งช่วยให้สถาปัตยกรรมทั้งหมดสามารถถูกนำไปใช้งานจริงได้อย่างมั่นคงและปลอดภัย

--------------------------------------------------------------------------------

## 8. สถาปัตยกรรมการนำไปใช้งาน (Deployment Architecture)

สถาปัตยกรรมการนำไปใช้งาน (Deployment Architecture) ของ UET Platform ถูกออกแบบมาเพื่อรองรับการทำงานของระบบที่ซับซ้อน, ขับเคลื่อนด้วยอีเวนต์, และต้องการความสามารถในการขยายขนาดสูง เพื่อให้มั่นใจได้ว่าแพลตฟอร์มจะทำงานได้อย่างมีเสถียรภาพและพร้อมใช้งานตลอดเวลา

องค์ประกอบสำคัญของสถาปัตยกรรมการ Deployment มีดังนี้:

- **Runtime & Stack**
    - **Runtime:** **Bun** ถูกเลือกใช้เป็น Runtime หลักเนื่องจากมีประสิทธิภาพสูงและเหมาะสำหรับ Workload ของ Agent และ API
    - **Containerization:** **Docker** ถูกใช้เพื่อสร้างสภาพแวดล้อมที่สอดคล้องกันสำหรับการพัฒนาและการนำไปใช้งานจริง
    - **Database:** **PostgreSQL** สำหรับข้อมูลเชิงสัมพันธ์ และ **Vector DB** (เช่น Qdrant) สำหรับจัดเก็บ Embeddings
- **Deployment Modes** ระบบรองรับโหมดการติดตั้ง 3 รูปแบบเพื่อให้เหมาะสมกับความต้องการที่แตกต่างกัน:
    - **Single Server:** เหมาะสำหรับสภาพแวดล้อมการทดสอบหรือการใช้งานขนาดเล็ก
    - **Multi-Node:** แยกบริการหลัก (API, Vector DB, PostgreSQL) ออกจากกันเพื่อประสิทธิภาพที่ดีขึ้น
    - **Clustered:** ใช้ API Server หลายเครื่องและ Vector DB หลายโหนด เหมาะสำหรับการใช้งานที่ต้องการรองรับภาระงานสูง (High Load)
- **Scaling Strategy** แนวทางการขยายขนาดถูกออกแบบมาเพื่อป้องกันปัญหาคอขวดและข้อมูลขัดแย้งกัน:
    - **Agent Engine:** ใช้ **Worker Pool** ซึ่งสามารถเพิ่มจำนวน Worker ได้ตามภาระงานที่เพิ่มขึ้น
    - **Knowledge Sync Engine:** ใช้รูปแบบ **Single Leader** เพื่อป้องกันไม่ให้เกิดการซิงค์ข้อมูลพร้อมกันหลายแห่ง **หากไม่มีการควบคุมที่เข้มงวดนี้ การดำเนินการซิงค์พร้อมกันอาจนำไปสู่สภาวะแข่งขัน (Race Conditions) ส่งผลให้ Knowledge Registry เสียหายและละเมิดหลักการ Zero-Stale และ Deterministic Behavior ซึ่งเป็นหลักการหลักของระบบ รูปแบบนี้รับประกันความสมบูรณ์ของธุรกรรมสำหรับการอัปเดตองค์ความรู้ทั้งหมด**
- **High Availability (HA)** เพื่อป้องกันระบบล่มและรับประกันความพร้อมใช้งานของบริการ มีการใช้มาตรการดังต่อไปนี้:
    - **Health Checks:** มีการตรวจสอบสถานะของบริการต่าง ๆ อย่างสม่ำเสมอ
    - **Database Replication:** ใช้ Replica ของ PostgreSQL เพื่อสำรองข้อมูลและสลับการใช้งานเมื่อเกิดปัญหา
    - **KB Backup:** มีการสำรองข้อมูล Knowledge Base เป็นประจำทุกวัน

สถาปัตยกรรมที่นำเสนอทั้งหมดในเอกสารฉบับนี้ ตั้งแต่หลักการออกแบบไปจนถึงการนำไปใช้งานจริง เป็นรากฐานที่มั่นคงและผ่านการไตร่ตรองมาอย่างดี เพื่อสร้าง UET Platform ให้เป็นแพลตฟอร์มองค์ความรู้ที่ทรงพลัง, มีเสถียรภาพ, และพร้อมสำหรับการเติบโตในอนาคต