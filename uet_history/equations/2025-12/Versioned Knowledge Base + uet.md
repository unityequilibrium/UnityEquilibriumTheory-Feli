# ภาพรวมสถาปัตยกรรม: การสร้างฐานความรู้ที่มีเวอร์ชัน (Versioned Knowledge Base)

## 1. การจัดการเวอร์ชันขององค์ความรู้คืออะไร?

ในระบบ AI ที่มีความซับซ้อน การจัดการเวอร์ชันถือเป็นหัวใจสำคัญที่รับประกันความสอดคล้อง (Consistency), การทำงานที่คาดเดาผลได้ (Determinism), และความสามารถในการตรวจสอบย้อนกลับ (Traceability) ของข้อมูล สถาปัตยกรรมนี้มองว่าการจัดการเวอร์ชันเป็นข้อกำหนดพื้นฐานสำหรับการสร้างระบบ AI ระดับองค์กรที่สามารถตรวจสอบได้ (Auditable) ซึ่งแตกต่างอย่างสิ้นเชิงกับการจัดการเวอร์ชันของซอฟต์แวร์ทั่วไป การมีกลไกเวอร์ชันที่แข็งแกร่งช่วยให้มั่นใจได้ว่าทุกส่วนของระบบ ตั้งแต่การดึงข้อมูลไปจนถึงการให้เหตุผลของ AI Agent ล้วนทำงานบน "ความจริง" ชุดเดียวกัน ณ เวลาใดเวลาหนึ่ง

สำหรับระบบนี้ แนวคิดเรื่อง "การจัดการเวอร์ชันขององค์ความรู้" มีความหมายลึกซึ้งกว่าแค่การติดตามเวอร์ชันของไฟล์ แต่ครอบคลุมถึงสถานะของข้อมูลในทุกมิติ ทั้งข้อมูลดิบ, ข้อมูลที่ผ่านการประมวลผล (chunks), ค่า embeddings ที่ใช้แทนความหมาย, และที่สำคัญที่สุดคือโครงสร้างของกราฟความสัมพันธ์เชิงความหมาย (Semantic Graph) ทั้งหมดนี้ถูกจัดการอย่างเป็นระบบผ่านโมเดลเวอร์ชันหลัก 3 ประเภท:

- `**KB_VERSION**`: เวอร์ชันของฐานข้อมูลความรู้ทั้งหมด (L0–L5) ซึ่งจะถูกปรับเปลี่ยนทุกครั้งเมื่อมีการนำเข้าข้อมูลใหม่เข้ามาในระบบ เปรียบเสมือนหมายเลขเวอร์ชันหลักขององค์ความรู้ทั้งหมด นี่คือเวอร์ชันหลักที่ระบบปลายทาง เช่น RAG และ Agent ใช้ในการอ้างอิงสถานะของข้อมูลทั้งหมด
- `**VECTOR_VERSION**`: เวอร์ชันของโมเดล embedding ที่ใช้แปลงข้อความเป็นเวกเตอร์เชิงความหมาย เวอร์ชันนี้จะเปลี่ยนแปลงเมื่อผู้ให้บริการ (provider) มีการอัปเดตโมเดล ซึ่งอาจส่งผลต่อการตีความความหมายของข้อมูลทั้งหมด
- `**GRAPH_VERSION**`: เวอร์ชันของกราฟความรู้ (L3–L5) ซึ่งเป็นโครงสร้างที่แสดงความสัมพันธ์ระหว่างแนวคิดต่างๆ เวอร์ชันนี้จะเปลี่ยนแปลงเมื่อมีการรวมโหนด (merge node), เพิ่มความสัมพันธ์ใหม่ (add relation), หรือมีการอัปเดตตรรกะในการให้เหตุผล เป็นเวอร์ชันย่อยที่ติดตามการเปลี่ยนแปลงโครงสร้างเชิงความหมายโดยเฉพาะ เช่น การทำ Node Clustering (L3) หรือการอัปเดต Topology (L4)

`KS Engine (Knowledge Sync Engine)` คือกลไกหลักที่รับผิดชอบการสร้างและบริหารจัดการเวอร์ชันเหล่านี้ทั้งหมด โดยทำหน้าที่เป็น "สายการผลิต" ที่แปลงข้อมูลดิบให้กลายเป็นองค์ความรู้ที่มีโครงสร้างและมีเวอร์ชันกำกับอย่างชัดเจน เมื่อเข้าใจถึงนิยามและความสำคัญแล้ว ต่อไปเราจะมาเจาะลึกถึงรูปแบบและสถาปัตยกรรมที่ใช้ในการจัดการเวอร์ชันเหล่านี้

## 2. รูปแบบและสถาปัตยกรรมหลักที่ใช้งาน

สถาปัตยกรรมของระบบนี้ใช้แนวทางแบบหลายชั้นและคาดเดาผลได้ (Multi-layered, deterministic approach) ในการจัดการการอัปเดตข้อมูล ซึ่งมีความซับซ้อนและปลอดภัยกว่าการบันทึกทับเวอร์ชันเก่าแบบทั่วไป โดยมีรูปแบบสถาปัตยกรรมหลัก 3 รูปแบบที่ทำงานร่วมกัน

### 2.1 กราฟความรู้เชิงเวลาและการเก็บ Snapshot (Temporal Knowledge Graph & Snapshots)

หัวใจสำคัญของระบบคือการใช้ตาราง `kb_registry` เพื่อบันทึก "version snapshot" ของกราฟความรู้ทั้งหมดในแต่ละ `KB_VERSION` วิธีการนี้เปรียบเสมือนการถ่ายภาพของสถานะองค์ความรู้ทั้งหมดเก็บไว้ ทำให้เราสามารถย้อนกลับไปดูหรือใช้งานกราฟความรู้ ณ เวอร์ชันใดก็ได้ในอดีต ซึ่งเป็นการสร้างกราฟความรู้เชิงเวลา (Temporal Knowledge Graph) ขึ้นมาอย่างมีประสิทธิภาพ

เพื่อรับประกันความเสถียรของระบบปลายทาง เช่น RAG Engine และ Agent Engine ที่ต้องอ้างอิงถึงโหนดความรู้ต่างๆ สถาปัตยกรรมบังคับใช้กฎการออกแบบที่สำคัญที่สุดคือ `RULE M1 — canonical_id NEVER changes` ซึ่งหมายความว่า ID หลักของโหนดความรู้จะไม่มีวันเปลี่ยนแปลง ทำให้ระบบอื่นสามารถอ้างอิงถึงแนวคิด (concept) เดิมได้อย่างถูกต้องเสมอ แม้ว่ารายละเอียดภายในโหนดจะมีการปรับปรุงในเวอร์ชันใหม่ก็ตาม

### 2.2 การซิงค์ความหมายแบบหลายชั้น (Multi-Layered Semantic Synchronization)

การอัปเดตข้อมูลไม่ได้เกิดขึ้นพร้อมกันทั้งหมดในครั้งเดียว แต่เป็นกระบวนการที่ละเอียดอ่อนและเกิดขึ้นในแต่ละชั้น (Layer) ขององค์ความรู้ ตารางด้านล่างสรุปกลยุทธ์การซิงโครไนซ์ข้อมูลในแต่ละชั้น

|   |   |   |
|---|---|---|
|Layer|ต้องการ Sync แบบไหน|กลไก (Mechanism)|
|L0|`full replace`|`hash-based`|
|L1|`full/diff`|`chunk diff`|
|L2|`full/diff`|`vector re-embed if needed`|
|L3|`merge/diff`|`node clustering`|
|L4|`merge`|`topology update`|
|L5|`extend/update`|`reasoning rules`|

กลไกนี้เปรียบเสมือนเครื่องมือ "Semantic Diff" ของระบบ ที่ช่วยให้การอัปเดตมีความละเอียดและประสิทธิภาพสูง โดยจะซิงโครไนซ์เฉพาะส่วนที่จำเป็นเท่านั้น กลไกนี้ถูกควบคุมโดย `KS Engine` ซึ่งจะประเมินว่าชั้นข้อมูลใด (`L0-L5`) ได้รับผลกระทบจากการเปลี่ยนแปลงและสั่งให้ซิงค์เฉพาะส่วนที่จำเป็นเท่านั้น การดำเนินการทั้งหมดจะถูกบันทึกผ่าน `Event Bus` ทำให้สามารถตรวจสอบย้อนกลับการเปลี่ยนแปลงเชิงความหมายแต่ละครั้งได้

### 2.3 รูปแบบการอัปเดตที่เน้นความปลอดภัยและการย้อนกลับ (Immutable-First Update Patterns & Rollback)

เพื่อรักษาประวัติการเปลี่ยนแปลงและป้องกันการสูญหายของข้อมูล สถาปัตยกรรมบังคับใช้กฎ `RULE K2 — No destructive update` ซึ่งห้ามการลบข้อมูลเชิงความหมายเก่าทิ้งโดยตรง การเปลี่ยนแปลงจะถูกบันทึกเป็นเวอร์ชันใหม่เสมอ แนวทางแบบ Immutable-First นี้เป็นการตัดสินใจเชิงสถาปัตยกรรมที่แลกประสิทธิภาพการจัดเก็บข้อมูลกับความสามารถในการตรวจสอบย้อนกลับและติดตามวิวัฒนาการของกราฟความรู้ ในระบบ AI ระดับโปรดักชัน การเข้าใจว่า _"ทำไม"_ ระบบจึงตัดสินใจเช่นนั้นมีความสำคัญเทียบเท่ากับการตัดสินใจนั้นเอง และกฎข้อนี้คือสิ่งที่รักษาร่องรอยทางประวัติศาสตร์ดังกล่าวไว้

ในกรณีที่การซิงค์ข้อมูลใหม่เกิดความขัดแย้งกับข้อมูลเดิม (เช่น การพยายามรวมโหนดที่มีความหมายไม่ตรงกัน) ระบบจะสร้างสถานะ `MergeConflict` ขึ้นมา ซึ่งจะบล็อกกระบวนการซิงค์ทั้งหมดและต้องการการตรวจสอบและแก้ไขโดยผู้ใช้ (manual resolve) เพื่อรับประกันความถูกต้องและความปลอดภัยสูงสุด

นอกจากนี้ State Machine ที่ควบคุมกระบวนการซิงค์ยังมีความสามารถในการ `ROLLBACK` กลับสู่สถานะที่สมบูรณ์ก่อนหน้าได้ทันทีเมื่อเกิดปัญหา เพื่อรักษาความสมบูรณ์ของข้อมูล (Data Integrity) อยู่เสมอ รูปแบบเหล่านี้ถูกนำไปใช้งานผ่านชุดของเอนจิ้นภายในและโครงสร้างข้อมูลที่ออกแบบมาโดยเฉพาะ

## 3. เครื่องมือและเฟรมเวิร์กที่เกี่ยวข้อง

สถาปัตยกรรมนี้ไม่ได้พึ่งพาเครื่องมือสำเร็จรูปเพียงอย่างเดียว แต่บูรณาการชุดเอนจิ้นที่ออกแบบขึ้นเอง (custom-designed engines) เข้ากับเครื่องมือมาตรฐานที่แข็งแกร่ง เพื่อให้การทำงานร่วมกันเป็นไปอย่างสมบูรณ์และไร้รอยต่อ ส่วนประกอบหลักที่ทำหน้าที่เป็น "เครื่องมือ" ในสถาปัตยกรรมนี้ประกอบด้วย:

1. **เอนจิ้นหลัก: Knowledge Sync (KS) Engine** KS Engine คือหัวใจของกระบวนการทั้งหมด ทำหน้าที่เป็น "สายการผลิต" (Production Line) ที่รับผิดชอบการแปลงข้อมูลดิบ (L0) ให้กลายเป็นกราฟความรู้ที่มีโครงสร้างและเวอร์ชันกำกับ (L3-L5) อย่างเป็นระบบและคาดเดาผลได้
2. **สถาปัตยกรรมข้อมูลแบบผสม (Hybrid Data Architecture)** ระบบเลือกใช้สถาปัตยกรรมข้อมูลแบบผสมผสานเพื่อดึงจุดเด่นของแต่ละเทคโนโลยีมาใช้งาน:
    - **Relational DB (PostgreSQL):** ใช้สำหรับจัดเก็บข้อมูลที่มีโครงสร้างสูง เช่น metadata ของไฟล์และ chunks (`files`, `chunks`), metadata ของกราฟ (`nodes/edges metadata`), สถานะของ Agent (`agent state`), logs และ events, และที่สำคัญคือตาราง `kb_registry` ที่ใช้เก็บ version snapshots ขององค์ความรู้ทั้งหมด
    - **Vector Index Store:** ใช้สำหรับจัดเก็บ embedding vectors โดยเฉพาะ เพื่อการค้นหาเชิงความหมาย (Semantic Similarity Search) ที่รวดเร็วและมีประสิทธิภาพ ซึ่งเป็นหัวใจสำคัญของ RAG Engine
3. **ระบบสนับสนุน (Supporting Systems)** เพื่อให้เอนจิ้นหลักทำงานได้อย่างสมบูรณ์ ระบบยังพึ่งพาระบบสนับสนุนที่ทำงานเบื้องหลัง:
    - **Event Bus System:** ทำหน้าที่เป็น "central truth of action history" บันทึกทุกการกระทำที่เกิดขึ้นในระบบ และเป็นตัวกระตุ้น (trigger) การทำงานของระบบอื่น
    - **Worker/Task System:** รับผิดชอบงานเบื้องหลังที่ใช้เวลานาน (long-running tasks) เช่น การสร้าง embeddings, การทำ re-indexing ให้กับ Vector Store, และการซิงค์ข้อมูลตามที่ได้รับคำสั่งจาก Event Bus

การเลือกใช้ส่วนประกอบและรูปแบบสถาปัตยกรรมเหล่านี้ล้วนมาจากการพิจารณาข้อดีข้อเสียอย่างรอบคอบ เพื่อให้ได้ผลลัพธ์ที่ดีที่สุด

## 4. ข้อดีและข้อเสียของแต่ละแนวทาง

สถาปัตยกรรมของระบบเป็นผลลัพธ์ของการหาจุดสมดุล (trade-offs) ระหว่างแนวทางต่างๆ เพื่อให้ได้ประสิทธิภาพสูงสุดในด้าน Determinism, Scalability, และความแม่นยำเชิงความหมาย ตารางด้านล่างนี้วิเคราะห์ข้อดีและข้อเสียของแนวทางการออกแบบหลักๆ ของระบบ

|   |   |   |
|---|---|---|
|แนวทาง (Approach)|ข้อดี (Pros)|ข้อเสีย/ความท้าทาย (Cons/Challenges)|
|**การซิงค์แบบรวมศูนย์และหลายชั้น (Centralized, Multi-Layered Sync)**|ควบคุมได้อย่างละเอียด, มีประสิทธิภาพ (ซิงค์เฉพาะชั้นที่จำเป็น), คาดเดาผลได้, ตรวจสอบย้อนกลับผ่าน Event Bus ได้|มีความซับซ้อนสูง, อาจเกิด `MergeConflict` ที่ต้องให้ผู้ใช้เข้ามาจัดการ|
|**กราฟความรู้แบบเสถียร (Immutable Canonical Graph)**|ระบบปลายทาง (RAG/Agent) ทำงานได้อย่างเสถียร, ป้องกันปัญหา `concept drift`, เอื้อต่อการทำ Cache|การเปลี่ยนแปลงความหมายหลักของโหนดเดิม (semantic redefinition) เป็นกระบวนการที่ต้องทำอย่างรอบคอบ (deliberate process) โดยระบบจะสนับสนุนการสร้างโหนดใหม่แทนการแก้ไขโหนดเก่าโดยตรง เพื่อรักษาความเสถียรของระบบปลายทาง|
|**การจัดเก็บข้อมูลแบบผสม (Hybrid Data Storage)**|ได้ประโยชน์จากทั้งสองระบบ: การ query ข้อมูลที่มีโครงสร้าง และการค้นหาเชิงความหมายที่รวดเร็ว|ต้องมีการซิงโครไนซ์ระหว่างสองระบบอย่างเข้มงวด หากเกิดความผิดพลาดอาจทำให้ข้อมูลไม่ตรงกัน (Data Inconsistency) เช่น เกิด `OrphanChunkDetected` ซึ่งระบบจะตรวจจับและส่งอีเวนต์ `RAG_EVENT.ORPHAN_DETECTED` ผ่าน Event Bus เพื่อสั่งให้ทำการ Rebuild Index ต่อไป|

บทพิสูจน์ที่แท้จริงของฐานความรู้ที่มีเวอร์ชันนี้ คือประสิทธิภาพในการบูรณาการเข้ากับระบบ AI ที่ใช้งานมัน

## 5. การบูรณาการกับระบบที่ใช้ LLM

สถาปัตยกรรมการจัดการเวอร์ชันทั้งหมดนี้ ถูกออกแบบมาโดยมีเป้าหมายหลักเพียงหนึ่งเดียว: เพื่อรับประกันว่า `RAG Engine` และ `Agent Engine` ทำงานบนฐานความจริง (Ground Truth) ที่มีเสถียรภาพ, คาดเดาผลได้, และตรวจสอบย้อนกลับได้เสมอ

### 5.1 กลไกตรวจสอบเวอร์ชันของ RAG Engine (Version Guard)

`RAG Engine` มีส่วนประกอบที่เรียกว่า `Version Guard` ทำหน้าที่เป็น "ยาม" คอยตรวจสอบว่า `kb_version` ที่ระบบ RAG กำลังจะดึงข้อมูลนั้น ตรงกับเวอร์ชันล่าสุดที่ถูกบันทึกไว้ใน `kb_registry` หรือไม่ หากเวอร์ชันไม่ตรงกัน ระบบจะปฏิเสธการทำงานทันที (`reject immediately`) และส่งอีเวนต์ `RAG_EVENT.VERSION_MISMATCH` ออกไป เพื่อป้องกันการใช้ข้อมูลที่ล้าสมัยซึ่งอาจนำไปสู่คำตอบที่ผิดพลาด

### 5.2 การให้เหตุผลที่คาดเดาผลได้ของ Agent Engine (Deterministic Reasoning)

หลักการที่สำคัญที่สุดของ `Agent Engine` คือการเป็น `Version-Bound Agent` ซึ่งหมายความว่า Agent ถูกบังคับให้ห้ามให้เหตุผลจากองค์ความรู้ที่มาจาก `kb_version` ที่แตกต่างกันในกระบวนการทำงานเดียว Agent ทุกตัวต้องตรวจสอบเวอร์ชันก่อนเริ่มกระบวนการให้เหตุผล และจะต้องใช้ `EvidenceSet` ที่ได้รับจาก RAG Engine ซึ่งเป็นข้อมูลแบบ zero-stale ที่ผ่านการตรวจสอบเวอร์ชันมาแล้วเท่านั้น เพื่อให้มั่นใจว่าการตัดสินใจทั้งหมดตั้งอยู่บนฐานข้อมูลชุดเดียวกัน

### 5.3 วงจรการเรียนรู้ของระบบ (The "Learning Loop" Workflow)

การทำงานร่วมกันของระบบต่างๆ ก่อให้เกิด "วงจรการเรียนรู้" ที่ทำให้ระบบสามารถพัฒนาความรู้ของตัวเองได้อย่างเป็นระบบและควบคุมได้ โดยมีขั้นตอนดังนี้:

`RAG → Agent → Tools → Knowledge Sync → Event Bus → RAG Refresh → Agent Resume`

วงจรนี้มีความสำคัญอย่างยิ่ง เพราะมันคือกลไกที่ Agent สามารถร้องขอการอัปเดตองค์ความรู้ได้ด้วยตนเองผ่านอีเวนต์ `AGENT_REQUEST_SYNC` เมื่อ Agent ค้นพบข้อมูลใหม่หรือสร้างข้อสรุปใหม่ขึ้นมา มันสามารถสั่งให้ `KS Engine` ทำงานเพื่อสร้าง KB เวอร์ชันใหม่ แล้วจึงดึงความรู้ที่เพิ่งปรับปรุงนั้นกลับมาใช้ในการให้เหตุผลขั้นต่อไปได้ทันที นี่คือหัวใจของการสร้างระบบที่มี 'controlled intelligence'—ซึ่งเป็นคุณสมบัติที่จำเป็นอย่างยิ่งสำหรับระบบ AI ที่ต้องทำงานได้อย่างน่าเชื่อถือ, ปลอดภัย, และตรวจสอบได้ในระดับโปรดักชัน