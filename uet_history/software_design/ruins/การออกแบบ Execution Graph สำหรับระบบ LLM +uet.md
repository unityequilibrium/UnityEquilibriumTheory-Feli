# เอกสารสรุป: การออกแบบ Execution Graph สำหรับระบบ LLM

เอกสารฉบับนี้สรุปแนวทางการออกแบบสถาปัตยกรรม Execution Graph สำหรับระบบที่ขับเคลื่อนด้วย Large Language Model (LLM) โดยสังเคราะห์ข้อมูลเชิงลึกจากเอกสารสถาปัตยกรรมระบบ, สัญญาของระบบ (System Contracts), และเฟรมเวิร์กโอเพนซอร์ส เพื่อนำเสนอภาพรวมที่ครอบคลุมสำหรับสถาปนิกและนักพัฒนา AI

--------------------------------------------------------------------------------

### 1. ภาพรวมของโมเดลการประมวลผล (Execution Models)

ในยุคแรกเริ่ม การพัฒนาระบบ LLM มักใช้รูปแบบ **"Chain"** หรือ "สายโซ่" ซึ่งเป็นการเชื่อมต่อการทำงานแบบเส้นตรง (Linear) ทีละขั้นตอน แม้จะง่ายต่อการสร้างต้นแบบ แต่ Chain ขาดความยืดหยุ่นในการจัดการกับสถานการณ์ที่ซับซ้อนและไม่สามารถปรับเปลี่ยนเส้นทางการทำงานตามผลลัพธ์ที่เกิดขึ้นระหว่างทางได้

เพื่อก้าวข้ามข้อจำกัดนี้ อุตสาหกรรมได้เปลี่ยนผ่านสู่โมเดลการประมวลผลแบบ **Execution Graph** ซึ่งเป็นสถาปัตยกรรมที่ยืดหยุ่นและทรงพลังกว่า โดยมองว่าเวิร์กโฟลว์ของ Agent คือกราฟที่ประกอบด้วยองค์ประกอบหลัก 3 ส่วน:

1. **State (สถานะร่วม):** เป็นโครงสร้างข้อมูลส่วนกลางที่แชร์กันระหว่างทุกส่วนของกราฟ ทำหน้าที่เสมือน "ไวท์บอร์ด" ที่เก็บข้อมูลปัจจุบัน, ผลลัพธ์ระหว่างทาง, ประวัติการสนทนา, และสถานะข้อผิดพลาด การมี State ที่ชัดเจนช่วยให้แต่ละขั้นตอนทำงานได้อย่างต่อเนื่องโดยไม่ต้องส่งต่อข้อมูลทั้งหมดไปมา และเป็นหัวใจของการสร้างเวิร์กโฟลว์ที่ตรวจสอบย้อนกลับได้
2. **Nodes (โหนด):** คือหน่วยการทำงานในกราฟ ซึ่งอาจเป็นฟังก์ชัน Python, การเรียกใช้เครื่องมือ (Tool Call), หรือการเรียก LLM เพื่อทำการตัดสินใจหรือสร้างเนื้อหา แต่ละโหนดจะรับ State ปัจจุบันเป็นอินพุต, ประมวลผล, และส่งคืนการอัปเดตไปยัง State
3. **Edges (เส้นเชื่อม):** คือตรรกะที่ควบคุมการไหลของข้อมูล (Control Flow) โดยกำหนดว่าหลังจากโหนดหนึ่งทำงานเสร็จสิ้น ควรจะไปยังโหนดใดต่อไป เส้นเชื่อมนี้อาจเป็นแบบคงที่ (Fixed Transition) หรือแบบมีเงื่อนไข (Conditional Edge) ซึ่งเป็นกลไกสำคัญที่ทำให้กราฟสามารถปรับเปลี่ยนเส้นทางการทำงานแบบไดนามิกได้

สถาปัตยกรรมแบบกราฟนี้ โดยเฉพาะอย่างยิ่ง **Directed Acyclic Graph (DAG)** ได้กลายเป็นมาตรฐานสำหรับการสร้างระบบ LLM ระดับโปรดักชัน เพราะช่วยให้สามารถจัดการกับความซับซ้อน, เพิ่มความน่าเชื่อถือ, และเปิดโอกาสให้เกิดพฤติกรรมของ Agent ที่ซับซ้อน เช่น การแก้ไขข้อผิดพลาดด้วยตนเอง (Self-Correction) และการวางแผนซ้ำ (Re-planning)

### 2. ตัวอย่างแผนภาพ (Diagram Examples)

แผนภาพ ASCII ต่อไปนี้แสดงตัวอย่างโครงสร้าง Execution Graph สำหรับกรณีใช้งานต่างๆ

**A) ไปป์ไลน์ RAG แบบปรับตัวได้ (Adaptive RAG Pipeline)**

- กราฟนี้แสดงลูปการแก้ไขตนเอง โดยมีการประเมินความเกี่ยวข้องของเอกสารก่อนสร้างคำตอบ

```
                +-----------------+
           +----| grade_documents |-----+
           |    +-----------------+     |
(irrelevant) |                          | (relevant)
           v                          v
+-------------+      +------------+      +----------------+      +----------+
| rewrite_query |----->|  retrieve  |<-----| query_decision |<-----|  START   |
+-------------+      +------------+      +----------------+      +----------+
                         |                                        ^
                         | (direct_answer)                        |
                         v                                        |
                    +----------+                                  | (no_retrieval)
                    | generate |----------------------------------+
                    +----------+                                  |
                         |                                        |
                         v                                        |
                    +----------+                                  |
                    |   END    |----------------------------------+
                    +----------+
```

**B) Agent Planner (สถาปัตยกรรม Plan-then-Execute)**

- แยกส่วนการวางแผน (Planner) ออกจากการลงมือทำ (Executor) อย่างชัดเจนเพื่อเพิ่มความปลอดภัยและคาดการณ์ได้

```
+-------+     +---------------+     +-----------------+     +-------------------+
| START |---->| planner_node  |---->| executor_node_1 |---->| should_continue ? |
+-------+     | (สร้างแผนงาน) |     | (ทำขั้นตอนที่ 1) |     +-------------------+
              +---------------+     +-----------------+              | (yes)
                                                                     |
                                                                     v
                                                              +-----------------+
                                                              | executor_node_2 |
                                                              +-----------------+
                                                                     |
                                                                     v
                                                                   [...]
                                                                     |
                                                                     v
                                                                   +-----+
                                                                   | END |
                                                                   +-----+
```

**C) ระบบ Multi-Agent ที่มีผู้ควบคุม (Orchestrated Multi-Agent System)**

- Orchestrator Agent ทำหน้าที่แจกจ่ายงานให้ Agent ผู้เชี่ยวชาญ และรวบรวมผลลัพธ์

```
                   +-------------------+
                   | Orchestrator/     |
                   | Supervisor Agent  |
                   +-------------------+
                      |             |
            (task_A)  |             | (task_B)
                      v             v
            +----------------+   +----------------+
            | Research Agent |   |  Writer Agent  |
            +----------------+   +----------------+
                      |             |
                      | (result_A)  | (result_B)
                      v             v
                   +-------------------+
                   |  Synthesis Node   |----->+-----+
                   +-------------------+      | END |
                                              +-----+
```

--------------------------------------------------------------------------------

### 3. กรณีศึกษาและตัวอย่างการใช้งาน

#### 3.1 Agent Planner (สถาปัตยกรรม Plan-then-Execute)

สถาปัตยกรรม "วางแผนแล้วลงมือทำ" (Plan-then-Execute หรือ P-t-E) เป็นรูปแบบการออกแบบที่สำคัญซึ่งแยกการคิดเชิงกลยุทธ์ออกจากการปฏิบัติการจริง

- **Planner Node:** รับคำร้องขอจากผู้ใช้และ State ของระบบ เพื่อสร้างแผนการทำงานที่มีโครงสร้างชัดเจน (เช่น รายการ Tool Calls ที่ต้องใช้พร้อมอาร์กิวเมนต์) แล้วบันทึกแผนนั้นลงใน State
- **Executor Node:** ดำเนินการตามแผนทีละขั้นตอน โดยรับข้อมูลจากแผนที่ถูกสร้างและตรวจสอบแล้วใน State เท่านั้น
- **ข้อดีเชิงความปลอดภัย:** การแยก Executor ออกจากบริบทดิบของผู้ใช้ช่วยลดความเสี่ยงจากการโจมตีแบบ Indirect Prompt Injection (IPI) ได้อย่างมาก เนื่องจาก Executor ไม่สามารถถูกชักจูงโดยข้อมูลประสงค์ร้ายที่อาจแฝงมาในเอกสารที่ RAG ดึงมาหรือผลลัพธ์จาก Tool อื่นๆ
- **การพัฒนาด้วย LangGraph:** เฟรมเวิร์กอย่าง LangGraph ได้ยกระดับ P-t-E จากกระบวนการเส้นตรงที่ตายตัวไปสู่กราฟที่ยืดหยุ่นและสามารถวนซ้ำได้ โดยการเพิ่มโหนด **Re-plan** เข้าไปในลูป `Execute → Re-plan → Execute` ทำให้ Agent สามารถตรวจสอบผลลัพธ์และปรับเปลี่ยนแผนได้หากเจอข้อผิดพลาดหรือผลลัพธ์ที่ไม่คาดคิด

#### 3.2 ไปป์ไลน์ RAG (RAG Pipelines)

Execution Graph ช่วยให้สามารถสร้างไปป์ไลน์ RAG ที่ซับซ้อนและชาญฉลาดกว่าเดิมได้

- **Adaptive RAG:** ระบบเริ่มต้นด้วย **Query Router Node** ที่ใช้ LLM เพื่อวิเคราะห์คำถามและตัดสินใจว่าจะตอบโดยตรง, ค้นหาข้อมูลจาก Vector Store, หรือแม้กระทั่งขอข้อมูลเพิ่มเติมจากผู้ใช้
- **Self-Correcting RAG:** หลังจากดึงข้อมูล (Retrieve), กราฟจะเข้าสู่ **Grade Documents Node** ซึ่งเป็น Conditional Edge ที่ใช้ LLM เพื่อประเมินว่าเอกสารที่ได้มานั้นเกี่ยวข้องกับคำถามหรือไม่
    - ถ้า **เกี่ยวข้อง (**`**yes**`**)**: กราฟจะเดินหน้าต่อไปยัง **Generate Node** เพื่อสร้างคำตอบ
    - ถ้า **ไม่เกี่ยวข้อง (**`**no**`**)**: กราฟจะถูกส่งไปยัง **Rewrite Question Node** เพื่อปรับปรุงคำถามให้ดีขึ้น แล้ววนกลับไปที่ Retrieve Node อีกครั้ง
- **Hallucination Check:** หลังจากสร้างคำตอบแล้ว สามารถเพิ่มโหนดตรวจสอบภาพหลอน (Hallucination) ซึ่งจะประเมินว่าคำตอบที่สร้างขึ้นนั้นสอดคล้องกับข้อมูลที่ดึงมาหรือไม่ หากไม่สอดคล้อง กราฟสามารถวนกลับไปเพื่อสร้างคำตอบใหม่หรือแจ้งให้ผู้ใช้ทราบ

#### 3.3 การประมวลผลแบบ Batch ขนาดใหญ่ (Large-Scale Batch Processing)

สำหรับงานที่ต้องประมวลผลข้อมูลจำนวนมากพร้อมกัน (เช่น การวิเคราะห์รีวิวลูกค้า 1,000 รายการ) การใช้ DAG เป็นสิ่งจำเป็นเพื่อจัดการการพึ่งพากันของข้อมูล, เพิ่มประสิทธิภาพการทำงานแบบขนาน, และลดต้นทุน

- **การจัดการ Dependency:** เฟรมเวิร์กอย่าง Haystack DAG ช่วยให้นิยามความสัมพันธ์ระหว่างโหนดได้อย่างชัดเจน (เช่น โหนด `classify` ต้องรอผลจากโหนด `filter_spam`) เพื่อให้ระบบสามารถจัดลำดับและรันโหนดที่ทำงานแบบขนานได้โดยอัตโนมัติ
- **Transformation Nodes:** เป็นคุณสมบัติสำคัญที่ช่วยลดต้นทุนได้อย่างมหาศาล ตัวอย่างเช่น แทนที่จะเรียก LLM วิเคราะห์รีวิวทั้ง 100 รายการแยกกัน สามารถมีโหนดที่จัดกลุ่มรีวิว 100 รายการเป็น 5 หมวดหมู่หลักก่อน แล้วจึงส่งให้ LLM วิเคราะห์เชิงลึกเพียง 5 ครั้ง
- **การจัดการ Scope:** DAG ที่ดีต้องจัดการขอบเขตการทำงานที่ต่างกันได้ เช่น การจัดหมวดหมู่ทำงานในขอบเขต "ต่อรายการ" (per-item) แต่การสรุปผลรวมทำงานในขอบเขต "ทั้งหมด" (global)

--------------------------------------------------------------------------------

### 4. รูปแบบการออกแบบที่แนะนำ (Suggested Design Patterns)

#### 4.1 การควบคุม Flow แบบ Directed Acyclic Graph (DAG)

การใช้ DAG เป็นรากฐานของระบบ Agent ที่ซับซ้อน ช่วยให้สามารถสร้างเวิร์กโฟลว์ที่คาดการณ์ได้และตรวจสอบได้ง่าย

- **Stateful Multi-Actor Systems:** เฟรมเวิร์กอย่าง **LangGraph** ถูกออกแบบมาเพื่อสร้างแอปพลิเคชันที่มี Agent หลายตัวและมีสถานะ (Stateful) โดยใช้กราฟเป็นแกนหลัก ช่วยให้สามารถสร้างลูป, การแตกแขนง, และการทำงานร่วมกันระหว่าง Agent ได้อย่างเป็นระบบ
- **Modular Pipelines:** เฟรมเวิร์กอย่าง **Haystack** เน้นการออกแบบไปป์ไลน์แบบโมดูลาร์ ทำให้สามารถสลับเปลี่ยนองค์ประกอบต่างๆ (เช่น Retriever, Re-ranker) ได้ง่ายโดยไม่กระทบกับส่วนอื่นของแอปพลิเคชัน เหมาะสำหรับระบบ RAG ที่ต้องการการปรับแต่งและประเมินผลอย่างต่อเนื่อง

#### 4.2 การกำหนดเส้นทางตามเงื่อนไข (Conditional Routing)

นี่คือหัวใจสำคัญที่ทำให้ Execution Graph มีความเป็นไดนามิก แทนที่จะมีเส้นทางที่ตายตัว กราฟสามารถตัดสินใจเลือกเส้นทางถัดไปตามสถานะ (State) ปัจจุบันได้

- **Router/Decision Node:** ใช้โหนดที่เรียก LLM เพื่อทำการตัดสินใจเชิงตรรกะ เช่น การวิเคราะห์คำถามของผู้ใช้เพื่อเลือกว่าจะใช้เครื่องมือใด (Tool), ค้นหาข้อมูลใน RAG, หรือตอบคำถามโดยตรง
- **Confidence Routing:** ตามที่ระบุใน System Contract, การเลือกเส้นทางสามารถขึ้นอยู่กับ "คะแนนความมั่นใจ" (Confidence Score) ที่ได้จาก RAG หรือการให้เหตุผลของ Agent
- **Conditional Edges ใน LangGraph:** เป็นกลไกหลักในการสร้างเงื่อนไข โดยใช้ฟังก์ชันที่รับ State เข้ามาและส่งคืนชื่อของโหนดถัดไป ทำให้การควบคุม Flow มีความโปร่งใสและตรวจสอบย้อนกลับได้

#### 4.3 กลยุทธ์การลองใหม่, การสำรอง, และงานแบบอะซิงโครนัส

ระบบระดับโปรดักชันต้องมีความทนทานต่อความล้มเหลวและทำงานได้อย่างมีประสิทธิภาพ

- **Retry Policy (การลองใหม่):** โหนดที่ต้องเชื่อมต่อกับบริการภายนอก (เช่น API, Database) ควรมีนโยบายการลองใหม่สำหรับข้อผิดพลาดชั่วคราว (Transient Failures) เช่น ปัญหาเครือข่าย เฟรมเวิร์กอย่าง LangGraph มี `RetryPolicy` ให้ใช้งาน
- **Failover/Fallback (การสำรอง):** เมื่อโหนดล้มเหลวอย่างถาวร กราฟควรมีเส้นทางสำรองไปยัง **Error Handler Node** ซึ่งอาจทำการบันทึกข้อผิดพลาด, แจ้งเตือน, หรือลองใช้กลยุทธ์อื่น เช่น การเปลี่ยนไปใช้ LLM ที่มีประสิทธิภาพสูงกว่าแต่แพงกว่าเพื่อทำงานให้สำเร็จ
- **Asynchronous & Parallel Tasks (งานอะซิงโครนัสและแบบขนาน):** สำหรับงาน Ingestion หรือ Batch Processing ควรออกแบบ DAG ให้สามารถประมวลผลโหนดที่ไม่ขึ้นต่อกันแบบขนานได้โดยใช้ **Worker Pool** หรือ **Async Scheduler** LangGraph รองรับรูปแบบ Map-Reduce ผ่านคำสั่ง `Send` ซึ่งช่วยให้กระจายงานไปยังโหนดต่างๆ เพื่อทำงานพร้อมกันได้

#### 4.4 เครื่องมือ Orchestrator แบบ Open-Source

|   |   |   |
|---|---|---|
|Framework|จุดเด่น|กรณีใช้งานที่เหมาะสมที่สุด|
|**LangGraph**|ออกแบบมาเพื่อสร้าง Agent ที่มีสถานะ (Stateful) และวนซ้ำได้ (Cyclic) โดยเฉพาะ ยกระดับจาก LangChain chains แบบเดิม สนับสนุนการสร้าง Multi-Agent ที่ซับซ้อนและการแก้ไขข้อผิดพลาดด้วยตนเอง|การสร้าง Agent ที่ต้องมีการวางแผน, การสะท้อนผล, การแก้ไขตนเอง, และการทำงานร่วมกันระหว่าง Agent หลายตัว เช่น Adaptive RAG, Re-planning Agents|
|**Haystack**|เฟรมเวิร์ก RAG ครบวงจรที่เน้นการใช้งานระดับโปรดักชัน มีระบบ DAG ที่ทรงพลังสำหรับจัดการไปป์ไลน์ข้อมูลที่ซับซ้อน, การประเมินผล, และการมอนิเตอร์|การสร้างระบบ RAG ที่ต้องการความน่าเชื่อถือสูง, การประมวลผลเอกสารแบบ Batch, และไปป์ไลน์ที่สามารถปรับเปลี่ยนและประเมินผลได้ง่าย|
|**LangFlow**|เป็นเครื่องมือที่ช่วยสร้าง Flow ของ LangChain และ LangGraph ผ่าน giao diện แบบลากและวาง (Drag-and-Drop)|การสร้างต้นแบบอย่างรวดเร็ว (Rapid Prototyping) และการทดลอง Flow ที่ซับซ้อนโดยไม่ต้องเขียนโค้ดทั้งหมดด้วยตนเอง เหมาะสำหรับทีมที่ต้องการเห็นภาพรวมของเวิร์กโฟลว์|
|**AutoGen**|เน้นการสร้าง Agent ที่ทำงานร่วมกันผ่านการสนทนา (Conversation-driven) มีความสามารถในการมอบหมายงานและทำงานร่วมกันแบบไดนามิก|ระบบ Multi-Agent ที่การทำงานเกิดขึ้นจากการ "สนทนา" และ "ตกลง" กันระหว่าง Agent เช่น ทีมนักพัฒนาซอฟต์แวร์ AI ที่มี Planner, Coder, และ Reviewer|