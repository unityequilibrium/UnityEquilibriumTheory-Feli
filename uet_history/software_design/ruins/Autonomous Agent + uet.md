# สถาปัตยกรรมระบบ Autonomous Agent

เอกสารฉบับนี้สรุปภาพรวมสถาปัตยกรรมของระบบ Agent อัตโนมัติ (Autonomous Agent Systems) โดยสังเคราะห์ข้อมูลเชิงลึกจากเอกสารทางเทคนิค, บทความวิจัย, และโครงการโอเพนซอร์ส เพื่อนำเสนอโครงสร้าง, รูปแบบการทำงาน, และแนวทางการพัฒนาที่ครอบคลุมและสามารถนำไปใช้งานได้จริงในระดับโปรดักชัน

## 1. สรุปรูปแบบสถาปัตยกรรมของ Agent (Agent Patterns)

Agent ในบริบทของ AI คือแอปพลิเคชันที่สร้างขึ้นจาก Generative AI ซึ่งมีความสามารถในการคิด, วางแผน, ใช้เหตุผล (reasoning), และใช้งานเครื่องมือ (tools) เพื่อบรรลุเป้าหมายที่กำหนดไว้ สถาปัตยกรรมของ Agent สมัยใหม่ได้พัฒนาจากโมเดลภาษา (LLM) แบบดั้งเดิมที่มีข้อจำกัด มาสู่ระบบที่ซับซ้อนและมีความสามารถสูงขึ้น

### แนวคิดหลัก: Agent คืออะไร?

Agent มีความสามารถเหนือกว่า LLM ทั่วไปในหลายมิติ:

- **การวางแผนและตัดสินใจ:** สามารถแบ่งงานที่ซับซ้อนออกเป็นขั้นตอนย่อยๆ และตัดสินใจเลือกทำขั้นตอนที่เหมาะสมได้
- **การใช้เครื่องมือ:** สามารถเชื่อมต่อกับระบบภายนอก เช่น ฐานข้อมูล, API, หรือการค้นหาเว็บ เพื่อดึงข้อมูล real-time หรือดำเนินการบางอย่างได้
- **ความสามารถในการซ่อมแซมตัวเอง:** เมื่อเกิดข้อผิดพลาดในขั้นตอนกลางทาง Agent สามารถประเมินและพยายามแก้ไขปัญหาเพื่อทำงานต่อได้ (Self-correction)
- **การทำงานร่วมกัน:** สามารถออกแบบให้ Agent หลายตัวทำงานร่วมกันในลักษณะของทีม (Multi-Agent System)

### รูปแบบ Planner-Executor-Reflector

นี่คือรูปแบบสถาปัตยกรรมพื้นฐานที่สำคัญสำหรับการสร้าง Agent ที่มีประสิทธิภาพและน่าเชื่อถือ

1. **Planner (ผู้วางแผน):** ทำหน้าที่วิเคราะห์เป้าหมายหลักและแตกออกเป็นแผนการทำงานแบบทีละขั้นตอน (step-by-step plan) ในระบบที่ซับซ้อน Planner อาจทำหน้าที่เลือกใช้ Agent หรือเครื่องมือที่เหมาะสมสำหรับแต่ละขั้นตอนด้วย รูปแบบสถาปัตยกรรมที่เรียกว่า **Plan-then-Execute (P-t-E)** เน้นการแยกส่วนการวางแผนออกจากการลงมือทำอย่างชัดเจน ซึ่งช่วยเพิ่มความสามารถในการคาดการณ์, ลดต้นทุน, และเสริมความปลอดภัยโดยเฉพาะการป้องกัน Prompt Injection
2. **Executor (ผู้ปฏิบัติการ):** ทำหน้าที่นำแผนที่ได้รับจาก Planner มาลงมือปฏิบัติการทีละขั้นตอน โดยการเรียกใช้เครื่องมือ (Tools) ที่จำเป็น เช่น การค้นหาข้อมูล, การเขียนโค้ด, หรือการเรียก API
3. **Reflector/Verifier (ผู้ทบทวน/ตรวจสอบ):** เป็นกลไกที่ช่วยให้ Agent สามารถประเมินการกระทำและผลลัพธ์ของตัวเองได้ รูปแบบนี้เรียกว่า **Reflection Loop** หรือ **Self-Critique Evaluator Loop** ซึ่ง Agent จะสร้างคำติชม (verbal self-reflections) เพื่อปรับปรุงการทำงานในครั้งต่อไป ช่วยลดข้อผิดพลาดและเพิ่มความแม่นยำในการทำงานที่ซับซ้อน

### วงจรการทำงาน (Execution Loops): ReAct, BabyAGI, และ LangGraph

- **ReAct (Reason-Act):** เป็นรูปแบบการทำงานที่ผสมผสานการใช้เหตุผล (Reasoning) และการกระทำ (Acting) เข้าด้วยกันเป็นวงจรต่อเนื่อง Agent จะคิดวิเคราะห์ (Thought), ตัดสินใจเลือกเครื่องมือ (Action), และสังเกตผลลัพธ์ (Observation) แล้ววนซ้ำไปเรื่อยๆ จนกว่าจะบรรลุเป้าหมาย เป็นรูปแบบที่ยืดหยุ่นแต่ในบางครั้งอาจคาดเดาได้ยาก
- **BabyAGI:** เป็นเฟรมเวิร์กที่ใช้วงจรการทำงานแบบวนซ้ำ ประกอบด้วยขั้นตอนหลักคือ การสร้างรายการงาน (Task Creation), การจัดลำดับความสำคัญ (Task Prioritization), และการลงมือทำ (Task Execution) โดยจะทำงานวนไปเรื่อยๆ เพื่อให้บรรลุเป้าหมายที่ใหญ่ขึ้น
- **LangGraph:** แตกต่างจาก LangChain ที่เป็น Directed Acyclic Graphs (DAGs) ซึ่งทำงานเป็นเส้นตรงและไม่สามารถย้อนกลับได้ LangGraph อนุญาตให้สร้าง **Stateful Graph** ที่มีวงจร (cycles) ได้ ทำให้สามารถสร้าง Workflow ที่ซับซ้อน, มีการวนซ้ำ, และมีการตัดสินใจแบบมีเงื่อนไขได้ง่ายขึ้น เหมาะอย่างยิ่งสำหรับการสร้างระบบ Multi-Agent และ ReAct loop ที่ต้องการความยืดหยุ่นสูง

## 2. การเปรียบเทียบ Use Case และ Workflow

สถาปัตยกรรมของ Agent สามารถแบ่งตามลักษณะการทำงานได้เป็น 2 รูปแบบหลัก คือ Single-Agent และ Multi-Agent ซึ่งแต่ละแบบมีจุดเด่นและเหมาะกับงานที่แตกต่างกัน

### Single-Agent Workflow (ReAct)

เหมาะสำหรับงานที่ไม่ซับซ้อนมากและสามารถทำจบได้ด้วย Agent ตัวเดียวที่ติดตั้งเครื่องมือหลายอย่าง Workflow นี้มักใช้ ReAct loop ในการทำงาน ตัวอย่างเช่น การตอบคำถามที่ต้องมีการค้นหาข้อมูลจากเว็บ

**ตัวอย่าง Use Case:**

- แชทบอทตอบคำถามทั่วไป
- Agent ช่วยเหลือในการเขียนโค้ดเบื้องต้น
- ระบบสรุปเอกสาร

### Multi-Agent Workflow (Hierarchical/Collaborative)

สำหรับงานที่ซับซ้อนซึ่งต้องการความเชี่ยวชาญเฉพาะทางหลายด้าน จะใช้สถาปัตยกรรมแบบ Multi-Agent โดยแต่ละ Agent จะมีบทบาท (Role) และเครื่องมือที่แตกต่างกันไป และมักจะมี **Supervisor/Orchestrator Agent** ทำหน้าที่เป็นผู้จัดการ คอยแจกจ่ายงานและรวบรวมผลลัพธ์

**ตัวอย่าง Use Case ในระบบ UET Platform:**

- **คำถามเชิงวิเคราะห์:** "ช่วยเปรียบเทียบ UET กับทฤษฎีระบบทั่วไป"
    1. **Analyst Agent:** แตกคำถามออกเป็น 3 หัวข้อย่อย (UET, Systems Theory, จุดแตกต่าง)
    2. **Research Agent:** ค้นหาข้อมูลจาก Knowledge Graph (KS) และ RAG Engine
    3. **Synthesis Agent:** รวบรวมข้อมูลทั้งหมดมาเรียบเรียงเป็นบทวิเคราะห์
    4. **Validate Agent:** ตรวจสอบความถูกต้องและความสอดคล้องของเนื้อหา
- **คำถามที่ต้องใช้เครื่องมือคำนวณ:** "คำนวณระยะทางของลูกบอลที่ยิงมุม 30° ด้วยความเร็ว 20 m/s"
    1. **Analyst Agent:** จัดประเภทคำถามเป็น "ฟิสิกส์ + คำนวณ"
    2. **RAG Agent:** ดึงสูตรที่เกี่ยวข้องจากฐานความรู้
    3. **Action Agent:** เรียกใช้เครื่องมือ Python เพื่อจำลองและคำนวณ
    4. **Validation Agent:** ตรวจสอบความสมเหตุสมผลของค่าทางฟิสิกส์
    5. **Final Answer Agent:** สร้างคำตอบสุดท้ายพร้อมกราฟ

### LangGraph: สถาปัตยกรรมแบบกราฟสถานะ (Stateful Graph)

LangGraph เป็นเฟรมเวิร์กที่เหมาะอย่างยิ่งสำหรับการสร้าง Workflow ที่ซับซ้อนเหล่านี้ โดยมีองค์ประกอบหลัก 3 ส่วน:

1. **State:** โครงสร้างข้อมูลที่ใช้ร่วมกันในทุกโหนดของกราฟ ทำหน้าที่เก็บสถานะปัจจุบันของงาน เช่น ประวัติการสนทนา, ผลลัพธ์จากเครื่องมือ
2. **Nodes:** ฟังก์ชันที่บรรจุ logic การทำงานของ Agent แต่ละตัว รับ State เข้ามาและส่งคืน State ที่อัปเดตแล้ว
3. **Edges:** เส้นเชื่อมที่กำหนดลำดับการทำงานของโหนดถัดไป สามารถเป็นได้ทั้งแบบตายตัว (Fixed) หรือแบบมีเงื่อนไข (Conditional) เพื่อสร้างการแตกแขนง (branching) ของ Workflow

## 3. ตัวอย่างโค้ดและผังการทำงาน (Code/Flowchart Examples)

### ผังการทำงาน ReAct Loop ใน LangGraph

วงจร ReAct สามารถสร้างได้ง่ายใน LangGraph โดยใช้ Conditional Edge เพื่อตัดสินใจว่าจะเรียกใช้เครื่องมือหรือจะจบการทำงาน

```ascii
           +-----------------+
           |   User Input    |
           +-------+---------+
                   |
                   v
+------------------+------------------+
|      call_model (Agent Node)        |
| - LLM ตัดสินใจว่าจะใช้เครื่องมือไหม?   |
+------------------+------------------+
                   |
                   v
      +------------+-------------+
      | should_continue (Edge) |
      | - ตรวจสอบว่ามี tool_calls |
      |   ในคำตอบของ LLM หรือไม่   |
      +------------+-------------+
         |                      |
(tool_calls > 0)       (tool_calls == 0)
         |                      |
         v                      v
  +------+------+         +-----+-----+
  | call_tool |         |   END   |
  +------+------+         +-----------+
         |
         +----------------------> (กลับไป call_model)
```

### ผังการทำงาน Multi-Agent แบบลำดับชั้น (Hierarchical)

Workflow นี้แสดงการทำงานร่วมกันของ Agent หลายตัวโดยมี Supervisor เป็นผู้ควบคุม

```ascii
                       +-------------------------+
                       | User Query & Supervisor |
                       | (Orchestrator/Manager)  |
                       +-----------+-------------+
                                   |
             +---------------------+---------------------+
             | (Delegate Task 1)   | (Delegate Task 2)   |
             v                     v                     v
+----------------+      +----------------+      +----------------+
|  Worker Agent A  |      |  Worker Agent B  |      |  Worker Agent C  |
|  (e.g., Research)  |      |  (e.g., Coding)  |      | (e.g., Validation) |
+----------------+      +----------------+      +----------------+
             |                     |                     |
             +---------------------+---------------------+
                                   |
                                   v
                       +-----------+-------------+
                       |   Supervisor Synthesizes  |
                       |       Final Answer        |
                       +-------------------------+
```

## 4. การจัดการหน่วยความจำ (Memory Management)

หน่วยความจำ (Memory) เป็นหัวใจสำคัญที่ช่วยให้ Agent สามารถสนทนาต่อเนื่องและจดจำบริบทได้ LangGraph จัดการหน่วยความจำผ่าน **Checkpointers** ซึ่งทำหน้าที่บันทึกและโหลดสถานะของกราฟ (State) ในทุกๆ การทำงาน

### ประเภทของหน่วยความจำ

|   |   |   |
|---|---|---|
|ประเภท|ลักษณะการทำงาน|Use Case|
|**Temporary (In-Memory)**|ข้อมูลการสนทนาจะถูกเก็บไว้ในหน่วยความจำและจะหายไปเมื่อแอปพลิเคชันปิดตัวลง|เหมาะสำหรับการทดสอบ, การใช้งานที่ต้องการความเป็นส่วนตัวสูง|
|**Persistent (SQLite, etc.)**|สถานะการสนทนาจะถูกบันทึกลงในฐานข้อมูล ทำให้สามารถกลับมาสนทนาต่อได้แม้จะปิดแอปไปแล้ว|เหมาะสำหรับแชทบอทในระดับโปรดักชันที่ผู้ใช้คาดหวังความต่อเนื่อง|
|**Episodic Memory**|เก็บความทรงจำเป็นตอนๆ คล้ายประสบการณ์ ทำให้ Agent สามารถเรียกใช้เหตุการณ์ในอดีตมาประกอบการตัดสินใจได้|การเรียนรู้จากข้อผิดพลาดในอดีต|
|**Semantic Memory**|เก็บข้อมูลในรูปแบบของ Knowledge Graph เพื่อให้ Agent สามารถค้นหาความสัมพันธ์ที่ซับซ้อนได้|การตอบคำถามที่ต้องการความเข้าใจเชิงลึก|

### Agentic Memory: หน่วยความจำที่พัฒนาตัวเองได้

แนวคิดขั้นสูงคือ **A-Mem (Agentic Memory)** ซึ่งเป็นระบบที่ Agent สามารถจัดระเบียบและพัฒนาหน่วยความจำของตัวเองได้อย่างต่อเนื่อง โดยไม่จำเป็นต้องมีโครงสร้างที่กำหนดไว้ล่วงหน้า ระบบนี้ได้รับแรงบันดาลใจจากวิธี Zettelkasten โดยสร้างเครือข่ายความรู้ที่เชื่อมโยงถึงกันผ่านการทำดัชนีและเชื่อมโยงแบบไดนามิก ทำให้โครงสร้างความรู้ของ Agent มีความซับซ้อนและสมบูรณ์ยิ่งขึ้นเมื่อเวลาผ่านไป

## 5. โครงการ Open-Source สำหรับการพัฒนา Agent

ปัจจุบันมีเฟรมเวิร์กโอเพนซอร์สจำนวนมากที่ช่วยให้นักพัฒนาสามารถสร้างระบบ Agent ที่ซับซ้อนได้อย่างรวดเร็ว

|   |   |   |
|---|---|---|
|Framework|ลักษณะเด่น|Use Case ที่เหมาะสม|
|**LangChain / LangGraph**|เป็นแพลตฟอร์มพื้นฐานที่มีเครื่องมือครบครัน LangGraph มีความสามารถในการสร้าง Workflow แบบมีเงื่อนไขและวนซ้ำ|การสร้าง Agent และ Workflow ที่ปรับแต่งได้สูง, ระบบ RAG, แชทบอท|
|**CrewAI**|เน้นการสร้างทีม Agent (Multi-Agent) ที่ทำงานร่วมกัน มีโครงสร้างที่เข้าใจง่ายในการกำหนด Role, Goal, และ Task|ระบบที่ต้องการการทำงานร่วมกันของ Agent ผู้เชี่ยวชาญหลายตัว|
|**AutoGen (Microsoft)**|เฟรมเวิร์กที่เน้นการสนทนาระหว่าง Agent หลายตัว สามารถทำงานร่วมกับมนุษย์ (Human-in-the-loop) ได้|การแก้ปัญหาที่ซับซ้อน, การจำลองสถานการณ์, การเขียนโค้ดร่วมกัน|
|**LlamaIndex**|เชี่ยวชาญด้านการสร้างแอปพลิเคชันค้นหาและดึงข้อมูล (Search and Retrieval) โดยเฉพาะ RAG|การสร้างระบบ "แชทกับข้อมูลของคุณ" ที่มีประสิทธิภาพสูง|
|**Cheshire Cat AI**|เฟรมเวิร์กที่เน้นสถาปัตยกรรมแบบ Plugin ทำให้ปรับแต่งและขยายความสามารถของ Agent ได้ง่าย|การสร้าง Agent ที่มีความสามารถเฉพาะทางสูงผ่านการเชื่อมต่อกับเครื่องมือต่างๆ|
|**AutoAgent**|เฟรมเวิร์กที่มุ่งเน้นการสร้าง Workflow ของ Agent แบบอัตโนมัติและไม่ต้องเขียนโค้ด (Zero-Code)|การสร้างต้นแบบ (Prototyping) อย่างรวดเร็ว|

## 6. แนวทางการบูรณาการกับระบบองค์ความรู้ (Knowledge Systems)

ความสามารถที่แท้จริงของ Agent จะถูกปลดล็อกเมื่อสามารถเชื่อมต่อกับฐานความรู้ภายนอกได้อย่างมีประสิทธิภาพ โดยเฉพาะระบบ Retrieval-Augmented Generation (RAG) และ Knowledge Graphs (KG)

### การเชื่อมต่อ Agent กับ RAG Engine

Agentic RAG คือการที่ Agent เป็นผู้ตัดสินใจเองว่าจะ **"เมื่อไหร่"** และ **"อย่างไร"** ที่จะดึงข้อมูลจากภายนอก แทนที่จะดึงข้อมูลมาก่อนแล้วค่อยตอบเสมอไป

**ขั้นตอนการทำงานในระบบ UET Platform:**

1. **Flow Control Engine** รับคำขอจากผู้ใช้และวิเคราะห์เจตนา (Intent)
2. หากจำเป็นต้องใช้ข้อมูลภายนอก Flow Control จะเรียก **RAG Engine**
3. RAG Engine ทำการค้นหาข้อมูลจาก Vector Store (L2), ขยายความหมายผ่าน Semantic Nodes (L3), และสำรวจความสัมพันธ์ผ่าน Edges (L4)
4. RAG Engine สร้าง `context_frame` ซึ่งเป็นแพ็กเกจข้อมูลที่มีโครงสร้างและส่งต่อไปยัง **Agent Engine**
5. Agent Engine ใช้ `context_frame` ที่ได้รับมาเป็นส่วนหนึ่งในกระบวนการให้เหตุผล (Reasoning) เพื่อสร้างคำตอบที่อ้างอิงจากข้อมูล (Grounded)

### การใช้ Knowledge Graph เพื่อเพิ่มความแม่นยำ (GraphRAG)

การใช้ Knowledge Graph (KG) เป็นแหล่งข้อมูลสำหรับ RAG (GraphRAG) มีข้อได้เปรียบเหนือกว่า Vector Search ทั่วไป เพราะ KG สามารถเก็บความสัมพันธ์ที่ซับซ้อนระหว่างข้อมูลได้ ทำให้ Agent สามารถ:

- **ค้นหาข้อมูลเชิงสัมพันธ์:** เช่น "ใครคือผู้จัดการของโปรเจกต์ X และโปรเจกต์นั้นเชื่อมโยงกับแผนกใดบ้าง"
- **ลดการหลอน (Hallucination):** เนื่องจากคำตอบถูกสร้างขึ้นจากโครงสร้างความรู้ที่ชัดเจนและตรวจสอบได้
- **ให้บริบทที่ลึกซึ้ง:** การดึงข้อมูลจาก KG ช่วยให้ Agent เข้าใจภาพรวมของฐานข้อมูลได้ดีกว่าการดึงแค่ "chunk" ของข้อความที่คล้ายกัน

### การทำงานแบบกำหนดได้ (Deterministic Execution) ผ่าน Execution Graph

เพื่อให้ระบบ Agent ทำงานได้อย่างน่าเชื่อถือในระดับโปรดักชัน การทำงานจะต้องเป็นแบบ **Deterministic** คือให้ผลลัพธ์ที่คาดเดาและทำซ้ำได้ ระบบ UET Platform ใช้ **Execution Graph** เป็น "สมองรวม" ที่ควบคุมลำดับการทำงานของทุก Engine ในระบบ

- **Nodes:** แทนหน่วยการทำงานพื้นฐาน เช่น `RAG_VECTOR_SEARCH`, `AGENT_PLAN`, `AGENT_EXECUTE`
- **Edges:** แทนกฎที่กำหนดว่าหลังจากโหนดหนึ่งทำงานเสร็จแล้ว จะต้องไปที่โหนดไหนต่อ, ทำงานแบบ sync หรือ async, และมีเงื่อนไขอะไรบ้าง
- **Execution Rules:** กฎที่ควบคุมทั้งระบบ เช่น นโยบายการ Retry, Fallback paths, และการจัดการข้อผิดพลาด

การใช้ Execution Graph ทำให้มั่นใจได้ว่าเส้นทางการทำงานตั้งแต่การรับคำสั่ง, การดึงข้อมูล, การใช้เหตุผล, จนถึงการสร้างคำตอบ จะเป็นไปตามลำดับที่ออกแบบไว้เสมอ ซึ่งเป็นสิ่งจำเป็นอย่างยิ่งสำหรับการสร้างระบบ AI ที่ปลอดภัยและเชื่อถือได้